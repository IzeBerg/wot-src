import imp, sys, traceback, types
NO_DEBUG = 0
LEVEL1 = 1
LEVEL2 = 2
DEBUG = NO_DEBUG
OUTPUT_DIR = '.jit/output'
SRC_DIRS = ('wot', 'wot_ext')

def write(*args):
    newLst = []
    for a in args:
        newLst.append(str(a))

    msg = (' ').join(newLst)
    sys.stdout.write('%s\n' % (msg,))


def writeErr(*args):
    newLst = []
    for a in args:
        newLst.append(str(a))

    msg = (' ').join(newLst)
    sys.stderr.write('pydev debugger: %s\n' % (msg,))


def notifyInfo0(*args):
    writeErr(*args)


def notifyInfo(*args):
    if DEBUG >= LEVEL1:
        write(*args)


def notifyInfo2(*args):
    if DEBUG >= LEVEL2:
        write(*args)


def notifyError(*args):
    writeErr(*args)


def codeObjectsEqual(code0, code1):
    for d in dir(code0):
        if d.startswith('_') or 'lineno' in d:
            continue
        if getattr(code0, d) != getattr(code1, d):
            return False

    return True


def xreload(mod):
    r = Reload(mod)
    r.apply()
    foundChange = r.foundChange
    r = None
    return foundChange


class Reload(object):

    def __init__(self, mod):
        self.mod = mod
        self.foundChange = False
        self._onFinishCallbacks = []

    def apply(self):
        mod = self.mod
        self._onFinishCallbacks = []
        try:
            modname = mod.__name__
            modns = mod.__dict__
            i = modname.rfind('.')
            if i >= 0:
                pkgname, modname = modname[:i], modname[i + 1:]
            else:
                pkgname = None
            if pkgname:
                pkg = sys.modules[pkgname]
                path = pkg.__path__
            else:
                pkg = None
                path = None
            import os.path, ResMgr
            reloadFileName = os.path.dirname(mod.__file__)
            path = ResMgr.resolveToAbsolutePath(reloadFileName)
            paths = [ path.replace(OUTPUT_DIR, srcDir) for srcDir in SRC_DIRS ]
            stream, filename, (suffix, mode, kind) = imp.find_module(modname, paths)
            try:
                if kind not in (imp.PY_COMPILED, imp.PY_SOURCE):
                    notifyError('Could not find source to reload (mod: %s)' % (modname,))
                    return
                if kind == imp.PY_SOURCE:
                    source = stream.read()
                    code = compile(source, filename, 'exec')
                else:
                    import marshal
                    code = marshal.load(stream)
            finally:
                if stream:
                    stream.close()

            newNamespace = modns.copy()
            newNamespace.clear()
            newNamespace['__name__'] = modns['__name__']

            def _exec(exp, globalVars, localVars=None):
                if localVars is not None:
                    exec exp in globalVars, localVars
                else:
                    exec exp in globalVars
                return

            _exec(code, newNamespace)
            oldnames = set(modns)
            newnames = set(newNamespace)
            for name in newnames - oldnames:
                notifyInfo0('Added:', name, 'to namespace')
                self.foundChange = True
                modns[name] = newNamespace[name]

            for name in oldnames & newnames:
                self._update(modns, name, modns[name], newNamespace[name])

            self._handleNamespace(modns)
            for c in self._onFinishCallbacks:
                c()

            del self._onFinishCallbacks[:]
        except:
            traceback.print_exc()

        return

    def _handleNamespace(self, namespace, isClassNamespace=False):
        onFinish = None
        if isClassNamespace:
            xreloadAfterUpdate = getattr(namespace, '__xreload_after_reload_update__', None)
            if xreloadAfterUpdate is not None:
                self.foundChange = True
                onFinish = lambda : xreloadAfterUpdate()
        elif '__xreload_after_reload_update__' in namespace:
            xreloadAfterUpdate = namespace['__xreload_after_reload_update__']
            self.foundChange = True
            onFinish = lambda : xreloadAfterUpdate(namespace)
        if onFinish is not None:
            self._onFinishCallbacks.append(onFinish)
        return

    def _update(self, namespace, name, oldobj, newobj, isClassNamespace=False):
        try:
            notifyInfo2('Updating: ', oldobj)
            if oldobj is newobj:
                return
            if type(oldobj) is not type(newobj):
                notifyError('Type of: %s changed... Skipping.' % (oldobj,))
                return
            if isinstance(newobj, types.FunctionType):
                self._updateFunction(oldobj, newobj)
                return
            if isinstance(newobj, types.MethodType):
                self._updateMethod(oldobj, newobj)
                return
            if isinstance(newobj, classmethod):
                self._updateClassmethod(oldobj, newobj)
                return
            if isinstance(newobj, staticmethod):
                self._updateStaticmethod(oldobj, newobj)
                return
            if hasattr(types, 'ClassType'):
                classtype = (
                 types.ClassType, type)
            else:
                classtype = type
            if isinstance(newobj, classtype):
                self._updateClass(oldobj, newobj)
                return
            if hasattr(newobj, '__metaclass__') and hasattr(newobj, '__class__') and newobj.__metaclass__ == newobj.__class__:
                self._updateClass(oldobj, newobj)
                return
            if namespace is not None:
                if oldobj != newobj and str(oldobj) != str(newobj) and repr(oldobj) != repr(newobj):
                    xreloadOldNew = None
                    if isClassNamespace:
                        xreloadOldNew = getattr(namespace, '__xreload_old_new__', None)
                        if xreloadOldNew is not None:
                            self.foundChange = True
                            xreloadOldNew(name, oldobj, newobj)
                    elif '__xreload_old_new__' in namespace:
                        namespace[name] = newobj
                        xreloadOldNew = namespace['__xreload_old_new__']
                        xreloadOldNew(namespace, name, oldobj, newobj)
                        self.foundChange = True
        except:
            notifyError('Exception found when updating %s. Proceeding for other items.' % (name,))
            traceback.print_exc()

        return

    def _updateFunction(self, oldfunc, newfunc):
        oldfunc.__doc__ = newfunc.__doc__
        oldfunc.__dict__.update(newfunc.__dict__)
        try:
            newfunc.__code__
            attrName = '__code__'
        except AttributeError:
            newfunc.func_code
            attrName = 'func_code'

        oldCode = getattr(oldfunc, attrName)
        newCode = getattr(newfunc, attrName)
        if not codeObjectsEqual(oldCode, newCode):
            notifyInfo0('Updated function code:', oldfunc)
            setattr(oldfunc, attrName, newCode)
            self.foundChange = True
        try:
            oldfunc.__defaults__ = newfunc.__defaults__
        except AttributeError:
            oldfunc.func_defaults = newfunc.func_defaults

        return oldfunc

    def _updateMethod(self, oldmeth, newmeth):
        if hasattr(oldmeth, 'im_func') and hasattr(newmeth, 'im_func'):
            self._update(None, None, oldmeth.im_func, newmeth.im_func)
        elif hasattr(oldmeth, '__func__') and hasattr(newmeth, '__func__'):
            self._update(None, None, oldmeth.__func__, newmeth.__func__)
        return oldmeth

    def _updateClass(self, oldclass, newclass):
        olddict = oldclass.__dict__
        newdict = newclass.__dict__
        oldnames = set(olddict)
        newnames = set(newdict)
        for name in newnames - oldnames:
            setattr(oldclass, name, newdict[name])
            notifyInfo0('Added:', name, 'to', oldclass)
            self.foundChange = True

        for name in oldnames - newnames:
            notifyInfo('Removed:', name, 'from', oldclass)
            delattr(oldclass, name)

        for name in (oldnames & newnames) - set(['__dict__', '__doc__']):
            self._update(oldclass, name, olddict[name], newdict[name], isClassNamespace=True)

        oldBases = getattr(oldclass, '__bases__', None)
        newBases = getattr(newclass, '__bases__', None)
        toSet = lambda bases: set(map(lambda x: x.__name__, bases))
        if toSet(oldBases) != toSet(newBases):
            notifyError('Changing the hierarchy of a class is not supported. %s may be inconsistent., %s, %s' % (
             oldclass, oldBases, newBases))
        self._handleNamespace(oldclass, isClassNamespace=True)
        return

    def _updateClassmethod(self, oldcm, newcm):
        self._update(None, None, oldcm.__get__(0), newcm.__get__(0))
        return

    def _updateStaticmethod(self, oldsm, newsm):
        self._update(None, None, oldsm.__get__(0), newsm.__get__(0))
        return