from __future__ import print_function
from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
from future.builtins import super
from future.builtins import str
__all__ = [
 b'Generator', b'DecodedGenerator', b'BytesGenerator']
import re, sys, time, random, warnings
from io import StringIO, BytesIO
from future.backports.email._policybase import compat32
from future.backports.email.header import Header
from future.backports.email.utils import _has_surrogates
import future.backports.email.charset as _charset
UNDERSCORE = b'_'
NL = b'\n'
fcre = re.compile(b'^From ', re.MULTILINE)

class Generator(object):

    def __init__(self, outfp, mangle_from_=True, maxheaderlen=None, **_3to2kwargs):
        if b'policy' in _3to2kwargs:
            policy = _3to2kwargs[b'policy']
            del _3to2kwargs[b'policy']
        else:
            policy = None
        self._fp = outfp
        self._mangle_from_ = mangle_from_
        self.maxheaderlen = maxheaderlen
        self.policy = policy
        return

    def write(self, s):
        self._fp.write(s)

    def flatten(self, msg, unixfrom=False, linesep=None):
        policy = msg.policy if self.policy is None else self.policy
        if linesep is not None:
            policy = policy.clone(linesep=linesep)
        if self.maxheaderlen is not None:
            policy = policy.clone(max_line_length=self.maxheaderlen)
        self._NL = policy.linesep
        self._encoded_NL = self._encode(self._NL)
        self._EMPTY = b''
        self._encoded_EMTPY = self._encode(b'')
        old_gen_policy = self.policy
        old_msg_policy = msg.policy
        try:
            self.policy = policy
            msg.policy = policy
            if unixfrom:
                ufrom = msg.get_unixfrom()
                if not ufrom:
                    ufrom = b'From nobody ' + time.ctime(time.time())
                self.write(ufrom + self._NL)
            self._write(msg)
        finally:
            self.policy = old_gen_policy
            msg.policy = old_msg_policy

        return

    def clone(self, fp):
        return self.__class__(fp, self._mangle_from_, None, policy=self.policy)

    _encoded_EMPTY = b''

    def _new_buffer(self):
        return StringIO()

    def _encode(self, s):
        return s

    def _write_lines(self, lines):
        if not lines:
            return
        lines = lines.splitlines(True)
        for line in lines[:-1]:
            self.write(line.rstrip(b'\r\n'))
            self.write(self._NL)

        laststripped = lines[(-1)].rstrip(b'\r\n')
        self.write(laststripped)
        if len(lines[(-1)]) != len(laststripped):
            self.write(self._NL)

    def _write(self, msg):
        oldfp = self._fp
        try:
            self._fp = sfp = self._new_buffer()
            self._dispatch(msg)
        finally:
            self._fp = oldfp

        meth = getattr(msg, b'_write_headers', None)
        if meth is None:
            self._write_headers(msg)
        else:
            meth(self)
        self._fp.write(sfp.getvalue())
        return

    def _dispatch(self, msg):
        main = msg.get_content_maintype()
        sub = msg.get_content_subtype()
        specific = UNDERSCORE.join((main, sub)).replace(b'-', b'_')
        meth = getattr(self, b'_handle_' + specific, None)
        if meth is None:
            generic = main.replace(b'-', b'_')
            meth = getattr(self, b'_handle_' + generic, None)
            if meth is None:
                meth = self._writeBody
        meth(msg)
        return

    def _write_headers(self, msg):
        for h, v in msg.raw_items():
            self.write(self.policy.fold(h, v))

        self.write(self._NL)

    def _handle_text(self, msg):
        payload = msg.get_payload()
        if payload is None:
            return
        else:
            if not isinstance(payload, str):
                raise TypeError(b'string payload expected: %s' % type(payload))
            if _has_surrogates(msg._payload):
                charset = msg.get_param(b'charset')
                if charset is not None:
                    del msg[b'content-transfer-encoding']
                    msg.set_payload(payload, charset)
                    payload = msg.get_payload()
            if self._mangle_from_:
                payload = fcre.sub(b'>From ', payload)
            self._write_lines(payload)
            return

    _writeBody = _handle_text

    def _handle_multipart(self, msg):
        msgtexts = []
        subparts = msg.get_payload()
        if subparts is None:
            subparts = []
        else:
            if isinstance(subparts, str):
                self.write(subparts)
                return
            if not isinstance(subparts, list):
                subparts = [subparts]
            for part in subparts:
                s = self._new_buffer()
                g = self.clone(s)
                g.flatten(part, unixfrom=False, linesep=self._NL)
                msgtexts.append(s.getvalue())

            boundary = msg.get_boundary()
            if not boundary:
                alltext = self._encoded_NL.join(msgtexts)
                boundary = self._make_boundary(alltext)
                msg.set_boundary(boundary)
            if msg.preamble is not None:
                if self._mangle_from_:
                    preamble = fcre.sub(b'>From ', msg.preamble)
                else:
                    preamble = msg.preamble
                self._write_lines(preamble)
                self.write(self._NL)
            self.write(b'--' + boundary + self._NL)
            if msgtexts:
                self._fp.write(msgtexts.pop(0))
            for body_part in msgtexts:
                self.write(self._NL + b'--' + boundary + self._NL)
                self._fp.write(body_part)

        self.write(self._NL + b'--' + boundary + b'--')
        if msg.epilogue is not None:
            self.write(self._NL)
            if self._mangle_from_:
                epilogue = fcre.sub(b'>From ', msg.epilogue)
            else:
                epilogue = msg.epilogue
            self._write_lines(epilogue)
        return

    def _handle_multipart_signed(self, msg):
        p = self.policy
        self.policy = p.clone(max_line_length=0)
        try:
            self._handle_multipart(msg)
        finally:
            self.policy = p

    def _handle_message_delivery_status(self, msg):
        blocks = []
        for part in msg.get_payload():
            s = self._new_buffer()
            g = self.clone(s)
            g.flatten(part, unixfrom=False, linesep=self._NL)
            text = s.getvalue()
            lines = text.split(self._encoded_NL)
            if lines and lines[(-1)] == self._encoded_EMPTY:
                blocks.append(self._encoded_NL.join(lines[:-1]))
            else:
                blocks.append(text)

        self._fp.write(self._encoded_NL.join(blocks))

    def _handle_message(self, msg):
        s = self._new_buffer()
        g = self.clone(s)
        payload = msg._payload
        if isinstance(payload, list):
            g.flatten(msg.get_payload(0), unixfrom=False, linesep=self._NL)
            payload = s.getvalue()
        else:
            payload = self._encode(payload)
        self._fp.write(payload)

    @classmethod
    def _make_boundary(cls, text=None):
        token = random.randrange(sys.maxsize)
        boundary = b'===============' + _fmt % token + b'=='
        if text is None:
            return boundary
        else:
            b = boundary
            counter = 0
            while True:
                cre = cls._compile_re(b'^--' + re.escape(b) + b'(--)?$', re.MULTILINE)
                if not cre.search(text):
                    break
                b = boundary + b'.' + str(counter)
                counter += 1

            return b

    @classmethod
    def _compile_re(cls, s, flags):
        return re.compile(s, flags)


class BytesGenerator(Generator):
    _encoded_EMPTY = b''

    def write(self, s):
        self._fp.write(str(s).encode(b'ascii', b'surrogateescape'))

    def _new_buffer(self):
        return BytesIO()

    def _encode(self, s):
        return s.encode(b'ascii')

    def _write_headers(self, msg):
        for h, v in msg.raw_items():
            self._fp.write(self.policy.fold_binary(h, v))

        self.write(self._NL)

    def _handle_text(self, msg):
        if msg._payload is None:
            return
        else:
            if _has_surrogates(msg._payload) and not self.policy.cte_type == b'7bit':
                if self._mangle_from_:
                    msg._payload = fcre.sub(b'>From ', msg._payload)
                self._write_lines(msg._payload)
            else:
                super(BytesGenerator, self)._handle_text(msg)
            return

    _writeBody = _handle_text

    @classmethod
    def _compile_re(cls, s, flags):
        return re.compile(s.encode(b'ascii'), flags)


_FMT = b'[Non-text (%(type)s) part of message omitted, filename %(filename)s]'

class DecodedGenerator(Generator):

    def __init__(self, outfp, mangle_from_=True, maxheaderlen=78, fmt=None):
        Generator.__init__(self, outfp, mangle_from_, maxheaderlen)
        if fmt is None:
            self._fmt = _FMT
        else:
            self._fmt = fmt
        return

    def _dispatch(self, msg):
        for part in msg.walk():
            maintype = part.get_content_maintype()
            if maintype == b'text':
                print(part.get_payload(decode=False), file=self)
            elif maintype == b'multipart':
                pass
            else:
                print(self._fmt % {b'type': part.get_content_type(), 
                   b'maintype': part.get_content_maintype(), 
                   b'subtype': part.get_content_subtype(), 
                   b'filename': part.get_filename(b'[no filename]'), 
                   b'description': part.get(b'Content-Description', b'[no description]'), 
                   b'encoding': part.get(b'Content-Transfer-Encoding', b'[no encoding]')}, file=self)


_width = len(repr(sys.maxsize - 1))
_fmt = b'%%0%dd' % _width
_make_boundary = Generator._make_boundary