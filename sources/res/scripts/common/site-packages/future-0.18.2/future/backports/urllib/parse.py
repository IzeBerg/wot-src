from __future__ import absolute_import, division, unicode_literals
from future.builtins import bytes, chr, dict, int, range, str
from future.utils import raise_with_traceback
import re, sys, collections
__all__ = [
 b'urlparse', b'urlunparse', b'urljoin', b'urldefrag',
 b'urlsplit', b'urlunsplit', b'urlencode', b'parse_qs',
 b'parse_qsl', b'quote', b'quote_plus', b'quote_from_bytes',
 b'unquote', b'unquote_plus', b'unquote_to_bytes']
uses_relative = [
 b'ftp', b'http', b'gopher', b'nntp', b'imap',
 b'wais', b'file', b'https', b'shttp', b'mms',
 b'prospero', b'rtsp', b'rtspu', b'', b'sftp',
 b'svn', b'svn+ssh']
uses_netloc = [b'ftp', b'http', b'gopher', b'nntp', b'telnet',
 b'imap', b'wais', b'file', b'mms', b'https', b'shttp',
 b'snews', b'prospero', b'rtsp', b'rtspu', b'rsync', b'',
 b'svn', b'svn+ssh', b'sftp', b'nfs', b'git', b'git+ssh']
uses_params = [b'ftp', b'hdl', b'prospero', b'http', b'imap',
 b'https', b'shttp', b'rtsp', b'rtspu', b'sip', b'sips',
 b'mms', b'', b'sftp', b'tel']
non_hierarchical = [
 b'gopher', b'hdl', b'mailto', b'news',
 b'telnet', b'wais', b'imap', b'snews', b'sip', b'sips']
uses_query = [b'http', b'wais', b'imap', b'https', b'shttp', b'mms',
 b'gopher', b'rtsp', b'rtspu', b'sip', b'sips', b'']
uses_fragment = [b'ftp', b'hdl', b'http', b'gopher', b'news',
 b'nntp', b'wais', b'https', b'shttp', b'snews',
 b'file', b'prospero', b'']
scheme_chars = b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-.'
MAX_CACHE_SIZE = 20
_parse_cache = {}

def clear_cache():
    _parse_cache.clear()
    _safe_quoters.clear()


_implicit_encoding = b'ascii'
_implicit_errors = b'strict'

def _noop(obj):
    return obj


def _encode_result(obj, encoding=_implicit_encoding, errors=_implicit_errors):
    return obj.encode(encoding, errors)


def _decode_args(args, encoding=_implicit_encoding, errors=_implicit_errors):
    return tuple((x.decode(encoding, errors) if x else b'') for x in args)


def _coerce_args(*args):
    str_input = isinstance(args[0], str)
    for arg in args[1:]:
        if arg and isinstance(arg, str) != str_input:
            raise TypeError(b'Cannot mix str and non-str arguments')

    if str_input:
        return args + (_noop,)
    return _decode_args(args) + (_encode_result,)


class _ResultMixinStr(object):
    __slots__ = ()

    def encode(self, encoding=b'ascii', errors=b'strict'):
        return self._encoded_counterpart(*(x.encode(encoding, errors) for x in self))


class _ResultMixinBytes(object):
    __slots__ = ()

    def decode(self, encoding=b'ascii', errors=b'strict'):
        return self._decoded_counterpart(*(x.decode(encoding, errors) for x in self))


class _NetlocResultMixinBase(object):
    __slots__ = ()

    @property
    def username(self):
        return self._userinfo[0]

    @property
    def password(self):
        return self._userinfo[1]

    @property
    def hostname(self):
        hostname = self._hostinfo[0]
        if not hostname:
            hostname = None
        elif hostname is not None:
            hostname = hostname.lower()
        return hostname

    @property
    def port(self):
        port = self._hostinfo[1]
        if port is not None:
            port = int(port, 10)
            if not 0 <= port <= 65535:
                return
        return port


class _NetlocResultMixinStr(_NetlocResultMixinBase, _ResultMixinStr):
    __slots__ = ()

    @property
    def _userinfo(self):
        netloc = self.netloc
        userinfo, have_info, hostinfo = netloc.rpartition(b'@')
        if have_info:
            username, have_password, password = userinfo.partition(b':')
            if not have_password:
                password = None
        else:
            username = password = None
        return (
         username, password)

    @property
    def _hostinfo(self):
        netloc = self.netloc
        _, _, hostinfo = netloc.rpartition(b'@')
        _, have_open_br, bracketed = hostinfo.partition(b'[')
        if have_open_br:
            hostname, _, port = bracketed.partition(b']')
            _, have_port, port = port.partition(b':')
        else:
            hostname, have_port, port = hostinfo.partition(b':')
        if not have_port:
            port = None
        return (
         hostname, port)


class _NetlocResultMixinBytes(_NetlocResultMixinBase, _ResultMixinBytes):
    __slots__ = ()

    @property
    def _userinfo(self):
        netloc = self.netloc
        userinfo, have_info, hostinfo = netloc.rpartition(b'@')
        if have_info:
            username, have_password, password = userinfo.partition(b':')
            if not have_password:
                password = None
        else:
            username = password = None
        return (
         username, password)

    @property
    def _hostinfo(self):
        netloc = self.netloc
        _, _, hostinfo = netloc.rpartition(b'@')
        _, have_open_br, bracketed = hostinfo.partition(b'[')
        if have_open_br:
            hostname, _, port = bracketed.partition(b']')
            _, have_port, port = port.partition(b':')
        else:
            hostname, have_port, port = hostinfo.partition(b':')
        if not have_port:
            port = None
        return (
         hostname, port)


from collections import namedtuple
_DefragResultBase = namedtuple(b'DefragResult', b'url fragment')
_SplitResultBase = namedtuple(b'SplitResult', b'scheme netloc path query fragment')
_ParseResultBase = namedtuple(b'ParseResult', b'scheme netloc path params query fragment')
ResultBase = _NetlocResultMixinStr

class DefragResult(_DefragResultBase, _ResultMixinStr):
    __slots__ = ()

    def geturl(self):
        if self.fragment:
            return self.url + b'#' + self.fragment
        else:
            return self.url


class SplitResult(_SplitResultBase, _NetlocResultMixinStr):
    __slots__ = ()

    def geturl(self):
        return urlunsplit(self)


class ParseResult(_ParseResultBase, _NetlocResultMixinStr):
    __slots__ = ()

    def geturl(self):
        return urlunparse(self)


class DefragResultBytes(_DefragResultBase, _ResultMixinBytes):
    __slots__ = ()

    def geturl(self):
        if self.fragment:
            return self.url + b'#' + self.fragment
        else:
            return self.url


class SplitResultBytes(_SplitResultBase, _NetlocResultMixinBytes):
    __slots__ = ()

    def geturl(self):
        return urlunsplit(self)


class ParseResultBytes(_ParseResultBase, _NetlocResultMixinBytes):
    __slots__ = ()

    def geturl(self):
        return urlunparse(self)


def _fix_result_transcoding():
    _result_pairs = (
     (
      DefragResult, DefragResultBytes),
     (
      SplitResult, SplitResultBytes),
     (
      ParseResult, ParseResultBytes))
    for _decoded, _encoded in _result_pairs:
        _decoded._encoded_counterpart = _encoded
        _encoded._decoded_counterpart = _decoded


_fix_result_transcoding()
del _fix_result_transcoding

def urlparse(url, scheme=b'', allow_fragments=True):
    url, scheme, _coerce_result = _coerce_args(url, scheme)
    splitresult = urlsplit(url, scheme, allow_fragments)
    scheme, netloc, url, query, fragment = splitresult
    if scheme in uses_params and b';' in url:
        url, params = _splitparams(url)
    else:
        params = b''
    result = ParseResult(scheme, netloc, url, params, query, fragment)
    return _coerce_result(result)


def _splitparams(url):
    if b'/' in url:
        i = url.find(b';', url.rfind(b'/'))
        if i < 0:
            return (url, b'')
    else:
        i = url.find(b';')
    return (
     url[:i], url[i + 1:])


def _splitnetloc(url, start=0):
    delim = len(url)
    for c in b'/?#':
        wdelim = url.find(c, start)
        if wdelim >= 0:
            delim = min(delim, wdelim)

    return (
     url[start:delim], url[delim:])


def urlsplit(url, scheme=b'', allow_fragments=True):
    url, scheme, _coerce_result = _coerce_args(url, scheme)
    allow_fragments = bool(allow_fragments)
    key = (url, scheme, allow_fragments, type(url), type(scheme))
    cached = _parse_cache.get(key, None)
    if cached:
        return _coerce_result(cached)
    else:
        if len(_parse_cache) >= MAX_CACHE_SIZE:
            clear_cache()
        netloc = query = fragment = b''
        i = url.find(b':')
        if i > 0:
            if url[:i] == b'http':
                scheme = url[:i].lower()
                url = url[i + 1:]
                if url[:2] == b'//':
                    netloc, url = _splitnetloc(url, 2)
                    if b'[' in netloc and b']' not in netloc or b']' in netloc and b'[' not in netloc:
                        raise ValueError(b'Invalid IPv6 URL')
                if allow_fragments and b'#' in url:
                    url, fragment = url.split(b'#', 1)
                if b'?' in url:
                    url, query = url.split(b'?', 1)
                v = SplitResult(scheme, netloc, url, query, fragment)
                _parse_cache[key] = v
                return _coerce_result(v)
            for c in url[:i]:
                if c not in scheme_chars:
                    break
            else:
                rest = url[i + 1:]
                if not rest or any(c not in b'0123456789' for c in rest):
                    scheme, url = url[:i].lower(), rest
        if url[:2] == b'//':
            netloc, url = _splitnetloc(url, 2)
            if b'[' in netloc and b']' not in netloc or b']' in netloc and b'[' not in netloc:
                raise ValueError(b'Invalid IPv6 URL')
        if allow_fragments and b'#' in url:
            url, fragment = url.split(b'#', 1)
        if b'?' in url:
            url, query = url.split(b'?', 1)
        v = SplitResult(scheme, netloc, url, query, fragment)
        _parse_cache[key] = v
        return _coerce_result(v)


def urlunparse(components):
    scheme, netloc, url, params, query, fragment, _coerce_result = _coerce_args(*components)
    if params:
        url = b'%s;%s' % (url, params)
    return _coerce_result(urlunsplit((scheme, netloc, url, query, fragment)))


def urlunsplit(components):
    scheme, netloc, url, query, fragment, _coerce_result = _coerce_args(*components)
    if netloc or scheme and scheme in uses_netloc and url[:2] != b'//':
        if url and url[:1] != b'/':
            url = b'/' + url
        url = b'//' + (netloc or b'') + url
    if scheme:
        url = scheme + b':' + url
    if query:
        url = url + b'?' + query
    if fragment:
        url = url + b'#' + fragment
    return _coerce_result(url)


def urljoin(base, url, allow_fragments=True):
    if not base:
        return url
    if not url:
        return base
    base, url, _coerce_result = _coerce_args(base, url)
    bscheme, bnetloc, bpath, bparams, bquery, bfragment = urlparse(base, b'', allow_fragments)
    scheme, netloc, path, params, query, fragment = urlparse(url, bscheme, allow_fragments)
    if scheme != bscheme or scheme not in uses_relative:
        return _coerce_result(url)
    if scheme in uses_netloc:
        if netloc:
            return _coerce_result(urlunparse((scheme, netloc, path,
             params, query, fragment)))
        netloc = bnetloc
    if path[:1] == b'/':
        return _coerce_result(urlunparse((scheme, netloc, path,
         params, query, fragment)))
    if not path and not params:
        path = bpath
        params = bparams
        if not query:
            query = bquery
        return _coerce_result(urlunparse((scheme, netloc, path,
         params, query, fragment)))
    segments = bpath.split(b'/')[:-1] + path.split(b'/')
    if segments[(-1)] == b'.':
        segments[-1] = b''
    while b'.' in segments:
        segments.remove(b'.')

    while 1:
        i = 1
        n = len(segments) - 1
        while 1:
            if i < n:
                if segments[i] == b'..' and segments[(i - 1)] not in ('', '..'):
                    del segments[i - 1:i + 1]
                    break
                i = i + 1
        else:
            break

    if segments == [b'', b'..']:
        segments[-1] = b''
    elif len(segments) >= 2 and segments[(-1)] == b'..':
        segments[(-2):] = [
         b'']
    return _coerce_result(urlunparse((scheme, netloc, (b'/').join(segments),
     params, query, fragment)))


def urldefrag(url):
    url, _coerce_result = _coerce_args(url)
    if b'#' in url:
        s, n, p, a, q, frag = urlparse(url)
        defrag = urlunparse((s, n, p, a, q, b''))
    else:
        frag = b''
        defrag = url
    return _coerce_result(DefragResult(defrag, frag))


_hexdig = b'0123456789ABCDEFabcdef'
_hextobyte = dict(((a + b).encode(), bytes([int(a + b, 16)])) for a in _hexdig for b in _hexdig)

def unquote_to_bytes(string):
    if not string:
        string.split
        return bytes(b'')
    if isinstance(string, str):
        string = string.encode(b'utf-8')
    string = bytes(string)
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    res = [
     bits[0]]
    append = res.append
    for item in bits[1:]:
        try:
            append(_hextobyte[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)

    return bytes(b'').join(res)


_asciire = re.compile(b'([\x00-\x7f]+)')

def unquote(string, encoding=b'utf-8', errors=b'replace'):
    if b'%' not in string:
        string.split
        return string
    else:
        if encoding is None:
            encoding = b'utf-8'
        if errors is None:
            errors = b'replace'
        bits = _asciire.split(string)
        res = [bits[0]]
        append = res.append
        for i in range(1, len(bits), 2):
            append(unquote_to_bytes(bits[i]).decode(encoding, errors))
            append(bits[(i + 1)])

        return (b'').join(res)


def parse_qs(qs, keep_blank_values=False, strict_parsing=False, encoding=b'utf-8', errors=b'replace'):
    parsed_result = {}
    pairs = parse_qsl(qs, keep_blank_values, strict_parsing, encoding=encoding, errors=errors)
    for name, value in pairs:
        if name in parsed_result:
            parsed_result[name].append(value)
        else:
            parsed_result[name] = [
             value]

    return parsed_result


def parse_qsl(qs, keep_blank_values=False, strict_parsing=False, encoding=b'utf-8', errors=b'replace'):
    qs, _coerce_result = _coerce_args(qs)
    pairs = [ s2 for s1 in qs.split(b'&') for s2 in s1.split(b';') ]
    r = []
    for name_value in pairs:
        if not name_value and not strict_parsing:
            continue
        nv = name_value.split(b'=', 1)
        if len(nv) != 2:
            if strict_parsing:
                raise ValueError(b'bad query field: %r' % (name_value,))
            if keep_blank_values:
                nv.append(b'')
            else:
                continue
        if len(nv[1]) or keep_blank_values:
            name = nv[0].replace(b'+', b' ')
            name = unquote(name, encoding=encoding, errors=errors)
            name = _coerce_result(name)
            value = nv[1].replace(b'+', b' ')
            value = unquote(value, encoding=encoding, errors=errors)
            value = _coerce_result(value)
            r.append((name, value))

    return r


def unquote_plus(string, encoding=b'utf-8', errors=b'replace'):
    string = string.replace(b'+', b' ')
    return unquote(string, encoding, errors)


_ALWAYS_SAFE = frozenset(bytes(b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-'))
_ALWAYS_SAFE_BYTES = bytes(_ALWAYS_SAFE)
_safe_quoters = {}

class Quoter(collections.defaultdict):

    def __init__(self, safe):
        self.safe = _ALWAYS_SAFE.union(bytes(safe))

    def __repr__(self):
        return b'<Quoter %r>' % dict(self)

    def __missing__(self, b):
        res = chr(b) if b in self.safe else (b'%{0:02X}').format(b)
        self[b] = res
        return res


def quote(string, safe=b'/', encoding=None, errors=None):
    if isinstance(string, str):
        if not string:
            return string
        if encoding is None:
            encoding = b'utf-8'
        if errors is None:
            errors = b'strict'
        string = string.encode(encoding, errors)
    else:
        if encoding is not None:
            raise TypeError(b"quote() doesn't support 'encoding' for bytes")
        if errors is not None:
            raise TypeError(b"quote() doesn't support 'errors' for bytes")
    return quote_from_bytes(string, safe)


def quote_plus(string, safe=b'', encoding=None, errors=None):
    if isinstance(string, str) and b' ' not in string or isinstance(string, bytes) and b' ' not in string:
        return quote(string, safe, encoding, errors)
    if isinstance(safe, str):
        space = str(b' ')
    else:
        space = bytes(b' ')
    string = quote(string, safe + space, encoding, errors)
    return string.replace(b' ', b'+')


def quote_from_bytes(bs, safe=b'/'):
    if not isinstance(bs, (bytes, bytearray)):
        raise TypeError(b'quote_from_bytes() expected bytes')
    if not bs:
        return str(b'')
    bs = bytes(bs)
    if isinstance(safe, str):
        safe = str(safe).encode(b'ascii', b'ignore')
    else:
        safe = bytes(safe)
        safe = bytes([ c for c in safe if c < 128 ])
    if not bs.rstrip(_ALWAYS_SAFE_BYTES + safe):
        return bs.decode()
    try:
        quoter = _safe_quoters[safe]
    except KeyError:
        _safe_quoters[safe] = quoter = Quoter(safe).__getitem__

    return str(b'').join([ quoter(char) for char in bs ])


def urlencode(query, doseq=False, safe=b'', encoding=None, errors=None):
    if hasattr(query, b'items'):
        query = query.items()
    else:
        try:
            if len(query) and not isinstance(query[0], tuple):
                raise TypeError
        except TypeError:
            ty, va, tb = sys.exc_info()
            raise_with_traceback(TypeError(b'not a valid non-string sequence or mapping object'), tb)

        l = []
        if not doseq:
            for k, v in query:
                if isinstance(k, bytes):
                    k = quote_plus(k, safe)
                else:
                    k = quote_plus(str(k), safe, encoding, errors)
                if isinstance(v, bytes):
                    v = quote_plus(v, safe)
                else:
                    v = quote_plus(str(v), safe, encoding, errors)
                l.append(k + b'=' + v)

        else:
            for k, v in query:
                if isinstance(k, bytes):
                    k = quote_plus(k, safe)
                else:
                    k = quote_plus(str(k), safe, encoding, errors)
                if isinstance(v, bytes):
                    v = quote_plus(v, safe)
                    l.append(k + b'=' + v)
                elif isinstance(v, str):
                    v = quote_plus(v, safe, encoding, errors)
                    l.append(k + b'=' + v)
                else:
                    try:
                        x = len(v)
                    except TypeError:
                        v = quote_plus(str(v), safe, encoding, errors)
                        l.append(k + b'=' + v)

                    for elt in v:
                        if isinstance(elt, bytes):
                            elt = quote_plus(elt, safe)
                        else:
                            elt = quote_plus(str(elt), safe, encoding, errors)
                        l.append(k + b'=' + elt)

    return str(b'&').join(l)


def to_bytes(url):
    if isinstance(url, str):
        try:
            url = url.encode(b'ASCII').decode()
        except UnicodeError:
            raise UnicodeError(b'URL ' + repr(url) + b' contains non-ASCII characters')

    return url


def unwrap(url):
    url = str(url).strip()
    if url[:1] == b'<' and url[-1:] == b'>':
        url = url[1:-1].strip()
    if url[:4] == b'URL:':
        url = url[4:].strip()
    return url


_typeprog = None

def splittype(url):
    global _typeprog
    if _typeprog is None:
        import re
        _typeprog = re.compile(b'^([^/:]+):')
    match = _typeprog.match(url)
    if match:
        scheme = match.group(1)
        return (
         scheme.lower(), url[len(scheme) + 1:])
    else:
        return (
         None, url)


_hostprog = None

def splithost(url):
    global _hostprog
    if _hostprog is None:
        import re
        _hostprog = re.compile(b'^//([^/?]*)(.*)$')
    match = _hostprog.match(url)
    if match:
        host_port = match.group(1)
        path = match.group(2)
        if path and not path.startswith(b'/'):
            path = b'/' + path
        return (host_port, path)
    else:
        return (
         None, url)


_userprog = None

def splituser(host):
    global _userprog
    if _userprog is None:
        import re
        _userprog = re.compile(b'^(.*)@(.*)$')
    match = _userprog.match(host)
    if match:
        return match.group(1, 2)
    else:
        return (
         None, host)


_passwdprog = None

def splitpasswd(user):
    global _passwdprog
    if _passwdprog is None:
        import re
        _passwdprog = re.compile(b'^([^:]*):(.*)$', re.S)
    match = _passwdprog.match(user)
    if match:
        return match.group(1, 2)
    else:
        return (
         user, None)


_portprog = None

def splitport(host):
    global _portprog
    if _portprog is None:
        import re
        _portprog = re.compile(b'^(.*):([0-9]+)$')
    match = _portprog.match(host)
    if match:
        return match.group(1, 2)
    else:
        return (
         host, None)


_nportprog = None

def splitnport(host, defport=-1):
    global _nportprog
    if _nportprog is None:
        import re
        _nportprog = re.compile(b'^(.*):(.*)$')
    match = _nportprog.match(host)
    if match:
        host, port = match.group(1, 2)
        try:
            if not port:
                raise ValueError(b'no digits')
            nport = int(port)
        except ValueError:
            nport = None

        return (host, nport)
    else:
        return (
         host, defport)


_queryprog = None

def splitquery(url):
    global _queryprog
    if _queryprog is None:
        import re
        _queryprog = re.compile(b'^(.*)\\?([^?]*)$')
    match = _queryprog.match(url)
    if match:
        return match.group(1, 2)
    else:
        return (
         url, None)


_tagprog = None

def splittag(url):
    global _tagprog
    if _tagprog is None:
        import re
        _tagprog = re.compile(b'^(.*)#([^#]*)$')
    match = _tagprog.match(url)
    if match:
        return match.group(1, 2)
    else:
        return (
         url, None)


def splitattr(url):
    words = url.split(b';')
    return (words[0], words[1:])


_valueprog = None

def splitvalue(attr):
    global _valueprog
    if _valueprog is None:
        import re
        _valueprog = re.compile(b'^([^=]*)=(.*)$')
    match = _valueprog.match(attr)
    if match:
        return match.group(1, 2)
    else:
        return (
         attr, None)