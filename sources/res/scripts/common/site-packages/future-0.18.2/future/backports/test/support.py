from __future__ import absolute_import, division, print_function, unicode_literals
from future import utils
from future.builtins import str, range, open, int, map, list
import contextlib, errno, functools, gc, socket, sys, os, platform, shutil, warnings, unittest
if not hasattr(unittest, b'skip'):
    import unittest2 as unittest
import importlib, re, subprocess, imp, time
try:
    import sysconfig
except ImportError:
    from distutils import sysconfig

import fnmatch, logging.handlers, struct, tempfile
try:
    if utils.PY3:
        import _thread, threading
    else:
        import thread as _thread, threading
except ImportError:
    _thread = None
    threading = None

try:
    import multiprocessing.process
except ImportError:
    multiprocessing = None

try:
    import zlib
except ImportError:
    zlib = None

try:
    import gzip
except ImportError:
    gzip = None

try:
    import bz2
except ImportError:
    bz2 = None

try:
    import lzma
except ImportError:
    lzma = None

__all__ = [
 b'Error', b'TestFailed', b'ResourceDenied', b'import_module', b'verbose',
 b'use_resources', b'max_memuse', b'record_original_stdout',
 b'get_original_stdout', b'unload', b'unlink', b'rmtree', b'forget',
 b'is_resource_enabled', b'requires', b'requires_freebsd_version',
 b'requires_linux_version', b'requires_mac_ver', b'find_unused_port',
 b'bind_port', b'IPV6_ENABLED', b'is_jython', b'TESTFN', b'HOST', b'SAVEDCWD',
 b'temp_cwd', b'findfile', b'create_empty_file', b'sortdict',
 b'check_syntax_error', b'open_urlresource', b'check_warnings', b'CleanImport',
 b'EnvironmentVarGuard', b'TransientResource', b'captured_stdout',
 b'captured_stdin', b'captured_stderr', b'time_out', b'socket_peer_reset',
 b'ioerror_peer_reset', b'run_with_locale', b'temp_umask',
 b'transient_internet', b'set_memlimit', b'bigmemtest', b'bigaddrspacetest',
 b'BasicTestRunner', b'run_unittest', b'run_doctest', b'threading_setup',
 b'threading_cleanup', b'reap_children', b'cpython_only', b'check_impl_detail',
 b'get_attribute', b'swap_item', b'swap_attr', b'requires_IEEE_754',
 b'TestHandler', b'Matcher', b'can_symlink', b'skip_unless_symlink',
 b'skip_unless_xattr', b'import_fresh_module', b'requires_zlib',
 b'PIPE_MAX_SIZE', b'failfast', b'anticipate_failure', b'run_with_tz',
 b'requires_gzip', b'requires_bz2', b'requires_lzma', b'suppress_crash_popup']

class Error(Exception):
    pass


class TestFailed(Error):
    pass


class ResourceDenied(unittest.SkipTest):
    pass


@contextlib.contextmanager
def _ignore_deprecated_imports(ignore=True):
    if ignore:
        with warnings.catch_warnings():
            warnings.filterwarnings(b'ignore', b'.+ (module|package)', DeprecationWarning)
            yield
    else:
        yield


def import_module(name, deprecated=False):
    with _ignore_deprecated_imports(deprecated):
        try:
            return importlib.import_module(name)
        except ImportError as msg:
            raise unittest.SkipTest(str(msg))


def _save_and_remove_module(name, orig_modules):
    if name not in sys.modules:
        __import__(name)
        del sys.modules[name]
    for modname in list(sys.modules):
        if modname == name or modname.startswith(name + b'.'):
            orig_modules[modname] = sys.modules[modname]
            del sys.modules[modname]


def _save_and_block_module(name, orig_modules):
    saved = True
    try:
        orig_modules[name] = sys.modules[name]
    except KeyError:
        saved = False

    sys.modules[name] = None
    return saved


def anticipate_failure(condition):
    if condition:
        return unittest.expectedFailure
    return lambda f: f


def import_fresh_module(name, fresh=(), blocked=(), deprecated=False):
    with _ignore_deprecated_imports(deprecated):
        orig_modules = {}
        names_to_remove = []
        _save_and_remove_module(name, orig_modules)
        try:
            try:
                for fresh_name in fresh:
                    _save_and_remove_module(fresh_name, orig_modules)

                for blocked_name in blocked:
                    if not _save_and_block_module(blocked_name, orig_modules):
                        names_to_remove.append(blocked_name)

                fresh_module = importlib.import_module(name)
            except ImportError:
                fresh_module = None

        finally:
            for orig_name, module in orig_modules.items():
                sys.modules[orig_name] = module

            for name_to_remove in names_to_remove:
                del sys.modules[name_to_remove]

        return fresh_module
    return


def get_attribute(obj, name):
    try:
        attribute = getattr(obj, name)
    except AttributeError:
        raise unittest.SkipTest(b'object %r has no attribute %r' % (obj, name))
    else:
        return attribute


verbose = 1
use_resources = None
max_memuse = 0
real_max_memuse = 0
failfast = False
match_tests = None
_original_stdout = None

def record_original_stdout(stdout):
    global _original_stdout
    _original_stdout = stdout


def get_original_stdout():
    return _original_stdout or sys.stdout


def unload(name):
    try:
        del sys.modules[name]
    except KeyError:
        pass


if sys.platform.startswith(b'win'):

    def _waitfor(func, pathname, waitall=False):
        func(pathname)
        if waitall:
            dirname = pathname
        else:
            dirname, name = os.path.split(pathname)
            dirname = dirname or b'.'
        timeout = 0.001
        while timeout < 1.0:
            L = os.listdir(dirname)
            if not (L if waitall else name in L):
                return
            time.sleep(timeout)
            timeout *= 2

        warnings.warn(b'tests may fail, delete still pending for ' + pathname, RuntimeWarning, stacklevel=4)


    def _unlink(filename):
        _waitfor(os.unlink, filename)


    def _rmdir(dirname):
        _waitfor(os.rmdir, dirname)


    def _rmtree(path):

        def _rmtree_inner(path):
            for name in os.listdir(path):
                fullname = os.path.join(path, name)
                if os.path.isdir(fullname):
                    _waitfor(_rmtree_inner, fullname, waitall=True)
                    os.rmdir(fullname)
                else:
                    os.unlink(fullname)

        _waitfor(_rmtree_inner, path, waitall=True)
        _waitfor(os.rmdir, path)


else:
    _unlink = os.unlink
    _rmdir = os.rmdir
    _rmtree = shutil.rmtree

def unlink(filename):
    try:
        _unlink(filename)
    except OSError as error:
        if error.errno not in (errno.ENOENT, errno.ENOTDIR):
            raise


def rmdir(dirname):
    try:
        _rmdir(dirname)
    except OSError as error:
        if error.errno != errno.ENOENT:
            raise


def rmtree(path):
    try:
        _rmtree(path)
    except OSError as error:
        if error.errno != errno.ENOENT:
            raise


def make_legacy_pyc(source):
    pyc_file = imp.cache_from_source(source)
    up_one = os.path.dirname(os.path.abspath(source))
    legacy_pyc = os.path.join(up_one, source + (b'c' if __debug__ else b'o'))
    os.rename(pyc_file, legacy_pyc)
    return legacy_pyc


def forget(modname):
    unload(modname)
    for dirname in sys.path:
        source = os.path.join(dirname, modname + b'.py')
        unlink(source + b'c')
        unlink(source + b'o')
        unlink(imp.cache_from_source(source, debug_override=True))
        unlink(imp.cache_from_source(source, debug_override=False))


if sys.platform.startswith(b'win'):
    import ctypes, ctypes.wintypes

    def _is_gui_available():
        UOI_FLAGS = 1
        WSF_VISIBLE = 1

        class USEROBJECTFLAGS(ctypes.Structure):
            _fields_ = [
             (
              b'fInherit', ctypes.wintypes.BOOL),
             (
              b'fReserved', ctypes.wintypes.BOOL),
             (
              b'dwFlags', ctypes.wintypes.DWORD)]

        dll = ctypes.windll.user32
        h = dll.GetProcessWindowStation()
        if not h:
            raise ctypes.WinError()
        uof = USEROBJECTFLAGS()
        needed = ctypes.wintypes.DWORD()
        res = dll.GetUserObjectInformationW(h, UOI_FLAGS, ctypes.byref(uof), ctypes.sizeof(uof), ctypes.byref(needed))
        if not res:
            raise ctypes.WinError()
        return bool(uof.dwFlags & WSF_VISIBLE)


else:

    def _is_gui_available():
        return True


def is_resource_enabled(resource):
    return use_resources is not None and resource in use_resources


def requires(resource, msg=None):
    if resource == b'gui' and not _is_gui_available():
        raise unittest.SkipTest(b"Cannot use the 'gui' resource")
    if sys._getframe(1).f_globals.get(b'__name__') == b'__main__':
        return
    else:
        if not is_resource_enabled(resource):
            if msg is None:
                msg = b'Use of the %r resource not enabled' % resource
            raise ResourceDenied(msg)
        return


def _requires_unix_version(sysname, min_version):

    def decorator(func):

        @functools.wraps(func)
        def wrapper(*args, **kw):
            if platform.system() == sysname:
                version_txt = platform.release().split(b'-', 1)[0]
                try:
                    version = tuple(map(int, version_txt.split(b'.')))
                except ValueError:
                    pass
                else:
                    if version < min_version:
                        min_version_txt = (b'.').join(map(str, min_version))
                        raise unittest.SkipTest(b'%s version %s or higher required, not %s' % (
                         sysname, min_version_txt, version_txt))
            return func(*args, **kw)

        wrapper.min_version = min_version
        return wrapper

    return decorator


def requires_freebsd_version(*min_version):
    return _requires_unix_version(b'FreeBSD', min_version)


def requires_linux_version(*min_version):
    return _requires_unix_version(b'Linux', min_version)


def requires_mac_ver(*min_version):

    def decorator(func):

        @functools.wraps(func)
        def wrapper(*args, **kw):
            if sys.platform == b'darwin':
                version_txt = platform.mac_ver()[0]
                try:
                    version = tuple(map(int, version_txt.split(b'.')))
                except ValueError:
                    pass
                else:
                    if version < min_version:
                        min_version_txt = (b'.').join(map(str, min_version))
                        raise unittest.SkipTest(b'Mac OS X %s or higher required, not %s' % (
                         min_version_txt, version_txt))
            return func(*args, **kw)

        wrapper.min_version = min_version
        return wrapper

    return decorator


HOST = b'127.0.0.1'
HOSTv6 = b'::1'

def find_unused_port(family=socket.AF_INET, socktype=socket.SOCK_STREAM):
    tempsock = socket.socket(family, socktype)
    port = bind_port(tempsock)
    tempsock.close()
    del tempsock
    return port


def bind_port(sock, host=HOST):
    if sock.family == socket.AF_INET and sock.type == socket.SOCK_STREAM:
        if hasattr(socket, b'SO_REUSEADDR'):
            if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR) == 1:
                raise TestFailed(b'tests should never set the SO_REUSEADDR socket option on TCP/IP sockets!')
        if hasattr(socket, b'SO_REUSEPORT'):
            try:
                if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT) == 1:
                    raise TestFailed(b'tests should never set the SO_REUSEPORT socket option on TCP/IP sockets!')
            except socket.error:
                pass

        if hasattr(socket, b'SO_EXCLUSIVEADDRUSE'):
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_EXCLUSIVEADDRUSE, 1)
    sock.bind((host, 0))
    port = sock.getsockname()[1]
    return port


def _is_ipv6_enabled():
    if socket.has_ipv6:
        sock = None
        try:
            try:
                sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
                sock.bind(('::1', 0))
                return True
            except (socket.error, socket.gaierror):
                pass

        finally:
            if sock:
                sock.close()

    return False


IPV6_ENABLED = _is_ipv6_enabled()
PIPE_MAX_SIZE = 4194305
SOCK_MAX_SIZE = 16777217
requires_zlib = unittest.skipUnless(zlib, b'requires zlib')
requires_bz2 = unittest.skipUnless(bz2, b'requires bz2')
requires_lzma = unittest.skipUnless(lzma, b'requires lzma')
is_jython = sys.platform.startswith(b'java')
if os.name == b'java':
    TESTFN = b'$test'
else:
    TESTFN = b'@test'
TESTFN = (b'{0}_{1}_tmp').format(TESTFN, os.getpid())
SAVEDCWD = os.getcwd()

@contextlib.contextmanager
def temp_cwd(name=b'tempcwd', quiet=False, path=None):
    saved_dir = os.getcwd()
    is_temporary = False
    if path is None:
        path = name
        try:
            os.mkdir(name)
            is_temporary = True
        except OSError:
            if not quiet:
                raise
            warnings.warn(b'tests may fail, unable to create temp CWD ' + name, RuntimeWarning, stacklevel=3)

    try:
        os.chdir(path)
    except OSError:
        if not quiet:
            raise
        warnings.warn(b'tests may fail, unable to change the CWD to ' + path, RuntimeWarning, stacklevel=3)

    try:
        yield os.getcwd()
    finally:
        os.chdir(saved_dir)
        if is_temporary:
            rmtree(name)

    return


if hasattr(os, b'umask'):

    @contextlib.contextmanager
    def temp_umask(umask):
        oldmask = os.umask(umask)
        try:
            yield
        finally:
            os.umask(oldmask)


def findfile(file, here=__file__, subdir=None):
    if os.path.isabs(file):
        return file
    else:
        if subdir is not None:
            file = os.path.join(subdir, file)
        path = sys.path
        path = [os.path.dirname(here)] + path
        for dn in path:
            fn = os.path.join(dn, file)
            if os.path.exists(fn):
                return fn

        return file


def create_empty_file(filename):
    fd = os.open(filename, os.O_WRONLY | os.O_CREAT | os.O_TRUNC)
    os.close(fd)


def sortdict(dict):
    items = sorted(dict.items())
    reprpairs = [ b'%r: %r' % pair for pair in items ]
    withcommas = (b', ').join(reprpairs)
    return b'{%s}' % withcommas


def make_bad_fd():
    file = open(TESTFN, b'wb')
    try:
        return file.fileno()
    finally:
        file.close()
        unlink(TESTFN)


def check_syntax_error(testcase, statement):
    testcase.assertRaises(SyntaxError, compile, statement, b'<test string>', b'exec')


def open_urlresource(url, *args, **kw):
    from future.backports.urllib import request as urllib_request, parse as urllib_parse
    check = kw.pop(b'check', None)
    filename = urllib_parse.urlparse(url)[2].split(b'/')[(-1)]
    fn = os.path.join(os.path.dirname(__file__), b'data', filename)

    def check_valid_file(fn):
        f = open(fn, *args, **kw)
        if check is None:
            return f
        else:
            if check(f):
                f.seek(0)
                return f
            f.close()
            return

    if os.path.exists(fn):
        f = check_valid_file(fn)
        if f is not None:
            return f
        unlink(fn)
    requires(b'urlfetch')
    print(b'\tfetching %s ...' % url, file=get_original_stdout())
    f = urllib_request.urlopen(url, timeout=15)
    try:
        with open(fn, b'wb') as (out):
            s = f.read()
            while s:
                out.write(s)
                s = f.read()

    finally:
        f.close()

    f = check_valid_file(fn)
    if f is not None:
        return f
    else:
        raise TestFailed(b'invalid resource %r' % fn)
        return


class WarningsRecorder(object):

    def __init__(self, warnings_list):
        self._warnings = warnings_list
        self._last = 0

    def __getattr__(self, attr):
        if len(self._warnings) > self._last:
            return getattr(self._warnings[(-1)], attr)
        else:
            if attr in warnings.WarningMessage._WARNING_DETAILS:
                return
            raise AttributeError(b'%r has no attribute %r' % (self, attr))
            return

    @property
    def warnings(self):
        return self._warnings[self._last:]

    def reset(self):
        self._last = len(self._warnings)


def _filterwarnings(filters, quiet=False):
    frame = sys._getframe(2)
    registry = frame.f_globals.get(b'__warningregistry__')
    if registry:
        if utils.PY3:
            registry.clear()
        else:
            for i in range(len(registry)):
                registry.pop()

    with warnings.catch_warnings(record=True) as (w):
        sys.modules[b'warnings'].simplefilter(b'always')
        yield WarningsRecorder(w)
    reraise = list(w)
    missing = []
    for msg, cat in filters:
        seen = False
        for w in reraise[:]:
            warning = w.message
            if re.match(msg, str(warning), re.I) and issubclass(warning.__class__, cat):
                seen = True
                reraise.remove(w)

        if not seen and not quiet:
            missing.append((msg, cat.__name__))

    if reraise:
        raise AssertionError(b'unhandled warning %s' % reraise[0])
    if missing:
        raise AssertionError(b'filter (%r, %s) did not catch any warning' % missing[0])


@contextlib.contextmanager
def check_warnings(*filters, **kwargs):
    quiet = kwargs.get(b'quiet')
    if not filters:
        filters = (
         (
          b'', Warning),)
        if quiet is None:
            quiet = True
    return _filterwarnings(filters, quiet)


class CleanImport(object):

    def __init__(self, *module_names):
        self.original_modules = sys.modules.copy()
        for module_name in module_names:
            if module_name in sys.modules:
                module = sys.modules[module_name]
                if module.__name__ != module_name:
                    del sys.modules[module.__name__]
                del sys.modules[module_name]

    def __enter__(self):
        return self

    def __exit__(self, *ignore_exc):
        sys.modules.update(self.original_modules)


if utils.PY3:
    import collections.abc
    mybase = collections.abc.MutableMapping
else:
    import UserDict
    mybase = UserDict.DictMixin

class EnvironmentVarGuard(mybase):

    def __init__(self):
        self._environ = os.environ
        self._changed = {}

    def __getitem__(self, envvar):
        return self._environ[envvar]

    def __setitem__(self, envvar, value):
        if envvar not in self._changed:
            self._changed[envvar] = self._environ.get(envvar)
        self._environ[envvar] = value

    def __delitem__(self, envvar):
        if envvar not in self._changed:
            self._changed[envvar] = self._environ.get(envvar)
        if envvar in self._environ:
            del self._environ[envvar]

    def keys(self):
        return self._environ.keys()

    def __iter__(self):
        return iter(self._environ)

    def __len__(self):
        return len(self._environ)

    def set(self, envvar, value):
        self[envvar] = value

    def unset(self, envvar):
        del self[envvar]

    def __enter__(self):
        return self

    def __exit__(self, *ignore_exc):
        for k, v in self._changed.items():
            if v is None:
                if k in self._environ:
                    del self._environ[k]
            else:
                self._environ[k] = v

        os.environ = self._environ
        return


class DirsOnSysPath(object):

    def __init__(self, *paths):
        self.original_value = sys.path[:]
        self.original_object = sys.path
        sys.path.extend(paths)

    def __enter__(self):
        return self

    def __exit__(self, *ignore_exc):
        sys.path = self.original_object
        sys.path[:] = self.original_value


class TransientResource(object):

    def __init__(self, exc, **kwargs):
        self.exc = exc
        self.attrs = kwargs

    def __enter__(self):
        return self

    def __exit__(self, type_=None, value=None, traceback=None):
        if type_ is not None and issubclass(self.exc, type_):
            for attr, attr_value in self.attrs.items():
                if not hasattr(value, attr):
                    break
                if getattr(value, attr) != attr_value:
                    break
            else:
                raise ResourceDenied(b'an optional resource is not available')

        return


time_out = TransientResource(IOError, errno=errno.ETIMEDOUT)
socket_peer_reset = TransientResource(socket.error, errno=errno.ECONNRESET)
ioerror_peer_reset = TransientResource(IOError, errno=errno.ECONNRESET)

@contextlib.contextmanager
def transient_internet(resource_name, timeout=30.0, errnos=()):
    default_errnos = [
     ('ECONNREFUSED', 111),
     ('ECONNRESET', 104),
     ('EHOSTUNREACH', 113),
     ('ENETUNREACH', 101),
     ('ETIMEDOUT', 110)]
    default_gai_errnos = [
     ('EAI_AGAIN', -3),
     ('EAI_FAIL', -4),
     ('EAI_NONAME', -2),
     ('EAI_NODATA', -5),
     ('WSANO_DATA', 11004)]
    denied = ResourceDenied(b'Resource %r is not available' % resource_name)
    captured_errnos = errnos
    gai_errnos = []
    if not captured_errnos:
        captured_errnos = [ getattr(errno, name, num) for name, num in default_errnos ]
        gai_errnos = [ getattr(socket, name, num) for name, num in default_gai_errnos
                     ]

    def filter_error(err):
        n = getattr(err, b'errno', None)
        if isinstance(err, socket.timeout) or isinstance(err, socket.gaierror) and n in gai_errnos or n in captured_errnos:
            if not verbose:
                sys.stderr.write(denied.args[0] + b'\n')
            exc = denied
            exc.__cause__ = err
            raise exc
        return

    old_timeout = socket.getdefaulttimeout()
    try:
        try:
            if timeout is not None:
                socket.setdefaulttimeout(timeout)
            yield
        except IOError as err:
            while True:
                a = err.args
                if len(a) >= 1 and isinstance(a[0], IOError):
                    err = a[0]
                elif len(a) >= 2 and isinstance(a[1], IOError):
                    err = a[1]
                else:
                    break

            filter_error(err)
            raise

    finally:
        socket.setdefaulttimeout(old_timeout)

    return


@contextlib.contextmanager
def captured_output(stream_name):
    import io
    orig_stdout = getattr(sys, stream_name)
    setattr(sys, stream_name, io.StringIO())
    try:
        yield getattr(sys, stream_name)
    finally:
        setattr(sys, stream_name, orig_stdout)


def captured_stdout():
    return captured_output(b'stdout')


def captured_stderr():
    return captured_output(b'stderr')


def captured_stdin():
    return captured_output(b'stdin')


def gc_collect():
    gc.collect()
    if is_jython:
        time.sleep(0.1)
    gc.collect()
    gc.collect()


@contextlib.contextmanager
def disable_gc():
    have_gc = gc.isenabled()
    gc.disable()
    try:
        yield
    finally:
        if have_gc:
            gc.enable()


def python_is_optimized():
    import sysconfig
    cflags = sysconfig.get_config_var(b'PY_CFLAGS') or b''
    final_opt = b''
    for opt in cflags.split():
        if opt.startswith(b'-O'):
            final_opt = opt

    return final_opt != b'' and final_opt != b'-O0'


_header = b'nP'
_align = b'0n'
if hasattr(sys, b'gettotalrefcount'):
    _header = b'2P' + _header
    _align = b'0P'
_vheader = _header + b'n'

def calcobjsize(fmt):
    return struct.calcsize(_header + fmt + _align)


def calcvobjsize(fmt):
    return struct.calcsize(_vheader + fmt + _align)


_TPFLAGS_HAVE_GC = 16384
_TPFLAGS_HEAPTYPE = 512

def check_sizeof(test, o, size):
    result = sys.getsizeof(o)
    if type(o) == type and o.__flags__ & _TPFLAGS_HEAPTYPE or type(o) != type and type(o).__flags__ & _TPFLAGS_HAVE_GC:
        size += _testcapi.SIZEOF_PYGC_HEAD
    msg = b'wrong size for %s: got %d, expected %d' % (
     type(o), result, size)
    test.assertEqual(result, size, msg)


def run_with_locale(catstr, *locales):

    def decorator(func):

        def inner(*args, **kwds):
            try:
                import locale
                category = getattr(locale, catstr)
                orig_locale = locale.setlocale(category)
            except AttributeError:
                raise
            except:
                locale = orig_locale = None

            for loc in locales:
                try:
                    locale.setlocale(category, loc)
                    break
                except:
                    pass

            try:
                return func(*args, **kwds)
            finally:
                if locale and orig_locale:
                    locale.setlocale(category, orig_locale)

            return

        inner.__name__ = func.__name__
        inner.__doc__ = func.__doc__
        return inner

    return decorator


def run_with_tz(tz):

    def decorator(func):

        def inner(*args, **kwds):
            try:
                tzset = time.tzset
            except AttributeError:
                raise unittest.SkipTest(b'tzset required')

            if b'TZ' in os.environ:
                orig_tz = os.environ[b'TZ']
            else:
                orig_tz = None
            os.environ[b'TZ'] = tz
            tzset()
            try:
                return func(*args, **kwds)
            finally:
                if orig_tz is None:
                    del os.environ[b'TZ']
                else:
                    os.environ[b'TZ'] = orig_tz
                time.tzset()

            return

        inner.__name__ = func.__name__
        inner.__doc__ = func.__doc__
        return inner

    return decorator


_1M = 1048576
_1G = 1024 * _1M
_2G = 2 * _1G
_4G = 4 * _1G
MAX_Py_ssize_t = sys.maxsize

def set_memlimit(limit):
    global max_memuse
    global real_max_memuse
    sizes = {b'k': 1024, 
       b'm': _1M, 
       b'g': _1G, 
       b't': 1024 * _1G}
    m = re.match(b'(\\d+(\\.\\d+)?) (K|M|G|T)b?$', limit, re.IGNORECASE | re.VERBOSE)
    if m is None:
        raise ValueError(b'Invalid memory limit %r' % (limit,))
    memlimit = int(float(m.group(1)) * sizes[m.group(3).lower()])
    real_max_memuse = memlimit
    if memlimit > MAX_Py_ssize_t:
        memlimit = MAX_Py_ssize_t
    if memlimit < _2G - 1:
        raise ValueError(b'Memory limit %r too low to be useful' % (limit,))
    max_memuse = memlimit
    return


class _MemoryWatchdog(object):

    def __init__(self):
        self.procfile = (b'/proc/{pid}/statm').format(pid=os.getpid())
        self.started = False

    def start(self):
        try:
            f = open(self.procfile, b'r')
        except OSError as e:
            warnings.warn((b'/proc not available for stats: {0}').format(e), RuntimeWarning)
            sys.stderr.flush()
            return

        watchdog_script = findfile(b'memory_watchdog.py')
        self.mem_watchdog = subprocess.Popen([sys.executable, watchdog_script], stdin=f, stderr=subprocess.DEVNULL)
        f.close()
        self.started = True

    def stop(self):
        if self.started:
            self.mem_watchdog.terminate()
            self.mem_watchdog.wait()


def bigmemtest(size, memuse, dry_run=True):

    def decorator(f):

        def wrapper(self):
            size = wrapper.size
            memuse = wrapper.memuse
            if not real_max_memuse:
                maxsize = 5147
            else:
                maxsize = size
            if (real_max_memuse or not dry_run) and real_max_memuse < maxsize * memuse:
                raise unittest.SkipTest(b'not enough memory: %.1fG minimum needed' % (size * memuse / 1073741824))
            if real_max_memuse and verbose:
                print()
                print((b' ... expected peak memory use: {peak:.1f}G').format(peak=size * memuse / 1073741824))
                watchdog = _MemoryWatchdog()
                watchdog.start()
            else:
                watchdog = None
            try:
                return f(self, maxsize)
            finally:
                if watchdog:
                    watchdog.stop()

            return

        wrapper.size = size
        wrapper.memuse = memuse
        return wrapper

    return decorator


def bigaddrspacetest(f):

    def wrapper(self):
        if max_memuse < MAX_Py_ssize_t:
            if MAX_Py_ssize_t >= 9223372036854775807 and max_memuse >= 2147483648:
                raise unittest.SkipTest(b'not enough memory: try a 32-bit build instead')
            else:
                raise unittest.SkipTest(b'not enough memory: %.1fG minimum needed' % (MAX_Py_ssize_t / 1073741824))
        else:
            return f(self)

    return wrapper


class BasicTestRunner(object):

    def run(self, test):
        result = unittest.TestResult()
        test(result)
        return result


def _id(obj):
    return obj


def requires_resource(resource):
    if resource == b'gui' and not _is_gui_available():
        return unittest.skip(b"resource 'gui' is not available")
    else:
        if is_resource_enabled(resource):
            return _id
        return unittest.skip((b'resource {0!r} is not enabled').format(resource))


def cpython_only(test):
    return impl_detail(cpython=True)(test)


def impl_detail(msg=None, **guards):
    if check_impl_detail(**guards):
        return _id
    else:
        if msg is None:
            guardnames, default = _parse_guards(guards)
            if default:
                msg = b'implementation detail not available on {0}'
            else:
                msg = b'implementation detail specific to {0}'
            guardnames = sorted(guardnames.keys())
            msg = msg.format((b' or ').join(guardnames))
        return unittest.skip(msg)


def _parse_guards(guards):
    if not guards:
        return ({b'cpython': True}, False)
    is_true = list(guards.values())[0]
    return (
     guards, not is_true)


def check_impl_detail(**guards):
    guards, default = _parse_guards(guards)
    return guards.get(platform.python_implementation().lower(), default)


def no_tracing(func):
    if not hasattr(sys, b'gettrace'):
        return func
    else:

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            original_trace = sys.gettrace()
            try:
                sys.settrace(None)
                return func(*args, **kwargs)
            finally:
                sys.settrace(original_trace)

            return

        return wrapper


def refcount_test(test):
    return no_tracing(cpython_only(test))


def _filter_suite(suite, pred):
    newtests = []
    for test in suite._tests:
        if isinstance(test, unittest.TestSuite):
            _filter_suite(test, pred)
            newtests.append(test)
        elif pred(test):
            newtests.append(test)

    suite._tests = newtests


def _run_suite(suite):
    if verbose:
        runner = unittest.TextTestRunner(sys.stdout, verbosity=2, failfast=failfast)
    else:
        runner = BasicTestRunner()
    result = runner.run(suite)
    if not result.wasSuccessful():
        if len(result.errors) == 1 and not result.failures:
            err = result.errors[0][1]
        elif len(result.failures) == 1 and not result.errors:
            err = result.failures[0][1]
        else:
            err = b'multiple errors occurred'
            if not verbose:
                err += b'; run in verbose mode for details'
        raise TestFailed(err)


def run_unittest(*classes):
    valid_types = (
     unittest.TestSuite, unittest.TestCase)
    suite = unittest.TestSuite()
    for cls in classes:
        if isinstance(cls, str):
            if cls in sys.modules:
                suite.addTest(unittest.findTestCases(sys.modules[cls]))
            else:
                raise ValueError(b'str arguments must be keys in sys.modules')
        elif isinstance(cls, valid_types):
            suite.addTest(cls)
        else:
            suite.addTest(unittest.makeSuite(cls))

    def case_pred(test):
        if match_tests is None:
            return True
        else:
            for name in test.id().split(b'.'):
                if fnmatch.fnmatchcase(name, match_tests):
                    return True

            return False

    _filter_suite(suite, case_pred)
    _run_suite(suite)


def run_doctest(module, verbosity=None, optionflags=0):
    import doctest
    if verbosity is None:
        verbosity = verbose
    else:
        verbosity = None
    f, t = doctest.testmod(module, verbose=verbosity, optionflags=optionflags)
    if f:
        raise TestFailed(b'%d of %d doctests failed' % (f, t))
    if verbose:
        print(b'doctest (%s) ... %d tests with zero failures' % (
         module.__name__, t))
    return (
     f, t)


def modules_setup():
    return (
     sys.modules.copy(),)


def modules_cleanup(oldmodules):
    encodings = [ (k, v) for k, v in sys.modules.items() if k.startswith(b'encodings.')
                ]
    for i in range(len(sys.modules)):
        sys.modules.pop()

    sys.modules.update(encodings)
    sys.modules.update(oldmodules)


def threading_setup():
    if _thread:
        return (_thread._count(),)
    else:
        return (1, )


def threading_cleanup(nb_threads):
    if not _thread:
        return
    _MAX_COUNT = 10
    for count in range(_MAX_COUNT):
        n = _thread._count()
        if n == nb_threads:
            break
        time.sleep(0.1)


def reap_threads(func):
    if not _thread:
        return func

    @functools.wraps(func)
    def decorator(*args):
        key = threading_setup()
        try:
            return func(*args)
        finally:
            threading_cleanup(*key)

    return decorator


def reap_children():
    if hasattr(os, b'waitpid'):
        any_process = -1
        while True:
            try:
                pid, status = os.waitpid(any_process, os.WNOHANG)
                if pid == 0:
                    break
            except:
                break


@contextlib.contextmanager
def swap_attr(obj, attr, new_val):
    if hasattr(obj, attr):
        real_val = getattr(obj, attr)
        setattr(obj, attr, new_val)
        try:
            yield
        finally:
            setattr(obj, attr, real_val)

    else:
        setattr(obj, attr, new_val)
        try:
            yield
        finally:
            delattr(obj, attr)


@contextlib.contextmanager
def swap_item(obj, item, new_val):
    if item in obj:
        real_val = obj[item]
        obj[item] = new_val
        try:
            yield
        finally:
            obj[item] = real_val

    else:
        obj[item] = new_val
        try:
            yield
        finally:
            del obj[item]


def strip_python_stderr(stderr):
    stderr = re.sub(b'\\[\\d+ refs\\]\\r?\\n?', b'', stderr).strip()
    return stderr


def args_from_interpreter_flags():
    return subprocess._args_from_interpreter_flags()


class TestHandler(logging.handlers.BufferingHandler):

    def __init__(self, matcher):
        logging.handlers.BufferingHandler.__init__(self, 0)
        self.matcher = matcher

    def shouldFlush(self):
        return False

    def emit(self, record):
        self.format(record)
        self.buffer.append(record.__dict__)

    def matches(self, **kwargs):
        result = False
        for d in self.buffer:
            if self.matcher.matches(d, **kwargs):
                result = True
                break

        return result


class Matcher(object):
    _partial_matches = ('msg', 'message')

    def matches(self, d, **kwargs):
        result = True
        for k in kwargs:
            v = kwargs[k]
            dv = d.get(k)
            if not self.match_value(k, dv, v):
                result = False
                break

        return result

    def match_value(self, k, dv, v):
        if type(v) != type(dv):
            result = False
        elif type(dv) is not str or k not in self._partial_matches:
            result = v == dv
        else:
            result = dv.find(v) >= 0
        return result


_can_symlink = None

def can_symlink():
    global _can_symlink
    if _can_symlink is not None:
        return _can_symlink
    else:
        symlink_path = TESTFN + b'can_symlink'
        try:
            os.symlink(TESTFN, symlink_path)
            can = True
        except (OSError, NotImplementedError, AttributeError):
            can = False
        else:
            os.remove(symlink_path)

        _can_symlink = can
        return can


def skip_unless_symlink(test):
    ok = can_symlink()
    msg = b'Requires functional symlink implementation'
    if ok:
        return test
    return unittest.skip(msg)(test)


_can_xattr = None

def can_xattr():
    global _can_xattr
    if _can_xattr is not None:
        return _can_xattr
    else:
        if not hasattr(os, b'setxattr'):
            can = False
        else:
            tmp_fp, tmp_name = tempfile.mkstemp()
            try:
                with open(TESTFN, b'wb') as (fp):
                    try:
                        os.setxattr(tmp_fp, b'user.test', b'')
                        os.setxattr(fp.fileno(), b'user.test', b'')
                        kernel_version = platform.release()
                        m = re.match(b'2.6.(\\d{1,2})', kernel_version)
                        can = m is None or int(m.group(1)) >= 39
                    except OSError:
                        can = False

            finally:
                unlink(TESTFN)
                unlink(tmp_name)

        _can_xattr = can
        return can


def skip_unless_xattr(test):
    ok = can_xattr()
    msg = b'no non-broken extended attribute support'
    if ok:
        return test
    return unittest.skip(msg)(test)


if sys.platform.startswith(b'win'):

    @contextlib.contextmanager
    def suppress_crash_popup():
        import ctypes
        k32 = ctypes.windll.kernel32
        SEM_NOGPFAULTERRORBOX = 2
        old_error_mode = k32.SetErrorMode(SEM_NOGPFAULTERRORBOX)
        k32.SetErrorMode(old_error_mode | SEM_NOGPFAULTERRORBOX)
        try:
            yield
        finally:
            k32.SetErrorMode(old_error_mode)


else:

    @contextlib.contextmanager
    def suppress_crash_popup():
        yield


def patch(test_instance, object_to_patch, attr_name, new_value):
    getattr(object_to_patch, attr_name)
    attr_is_local = False
    try:
        old_value = object_to_patch.__dict__[attr_name]
    except (AttributeError, KeyError):
        old_value = getattr(object_to_patch, attr_name, None)
    else:
        attr_is_local = True

    def cleanup():
        if attr_is_local:
            setattr(object_to_patch, attr_name, old_value)
        else:
            delattr(object_to_patch, attr_name)

    test_instance.addCleanup(cleanup)
    setattr(object_to_patch, attr_name, new_value)
    return