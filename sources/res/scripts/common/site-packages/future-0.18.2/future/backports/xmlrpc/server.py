from __future__ import absolute_import, division, print_function, unicode_literals
from future.builtins import int, str
from future.backports.xmlrpc.client import Fault, dumps, loads, gzip_encode, gzip_decode
from future.backports.http.server import BaseHTTPRequestHandler
import future.backports.http.server as http_server
from future.backports import socketserver
import sys, os, re, pydoc, inspect, traceback
try:
    import fcntl
except ImportError:
    fcntl = None

def resolve_dotted_attribute(obj, attr, allow_dotted_names=True):
    if allow_dotted_names:
        attrs = attr.split(b'.')
    else:
        attrs = [
         attr]
    for i in attrs:
        if i.startswith(b'_'):
            raise AttributeError(b'attempt to access private attribute "%s"' % i)
        else:
            obj = getattr(obj, i)

    return obj


def list_public_methods(obj):
    return [ member for member in dir(obj) if not member.startswith(b'_') and callable(getattr(obj, member))
           ]


class SimpleXMLRPCDispatcher(object):

    def __init__(self, allow_none=False, encoding=None, use_builtin_types=False):
        self.funcs = {}
        self.instance = None
        self.allow_none = allow_none
        self.encoding = encoding or b'utf-8'
        self.use_builtin_types = use_builtin_types
        return

    def register_instance(self, instance, allow_dotted_names=False):
        self.instance = instance
        self.allow_dotted_names = allow_dotted_names

    def register_function(self, function, name=None):
        if name is None:
            name = function.__name__
        self.funcs[name] = function
        return

    def register_introspection_functions(self):
        self.funcs.update({b'system.listMethods': self.system_listMethods, b'system.methodSignature': self.system_methodSignature, 
           b'system.methodHelp': self.system_methodHelp})

    def register_multicall_functions(self):
        self.funcs.update({b'system.multicall': self.system_multicall})

    def _marshaled_dispatch(self, data, dispatch_method=None, path=None):
        try:
            params, method = loads(data, use_builtin_types=self.use_builtin_types)
            if dispatch_method is not None:
                response = dispatch_method(method, params)
            else:
                response = self._dispatch(method, params)
            response = (response,)
            response = dumps(response, methodresponse=1, allow_none=self.allow_none, encoding=self.encoding)
        except Fault as fault:
            response = dumps(fault, allow_none=self.allow_none, encoding=self.encoding)
        except:
            exc_type, exc_value, exc_tb = sys.exc_info()
            response = dumps(Fault(1, b'%s:%s' % (exc_type, exc_value)), encoding=self.encoding, allow_none=self.allow_none)

        return response.encode(self.encoding)

    def system_listMethods(self):
        methods = set(self.funcs.keys())
        if self.instance is not None:
            if hasattr(self.instance, b'_listMethods'):
                methods |= set(self.instance._listMethods())
            elif not hasattr(self.instance, b'_dispatch'):
                methods |= set(list_public_methods(self.instance))
        return sorted(methods)

    def system_methodSignature(self, method_name):
        return b'signatures not supported'

    def system_methodHelp(self, method_name):
        method = None
        if method_name in self.funcs:
            method = self.funcs[method_name]
        elif self.instance is not None:
            if hasattr(self.instance, b'_methodHelp'):
                return self.instance._methodHelp(method_name)
            if not hasattr(self.instance, b'_dispatch'):
                try:
                    method = resolve_dotted_attribute(self.instance, method_name, self.allow_dotted_names)
                except AttributeError:
                    pass

        if method is None:
            return b''
        else:
            return pydoc.getdoc(method)
            return

    def system_multicall(self, call_list):
        results = []
        for call in call_list:
            method_name = call[b'methodName']
            params = call[b'params']
            try:
                results.append([self._dispatch(method_name, params)])
            except Fault as fault:
                results.append({b'faultCode': fault.faultCode, b'faultString': fault.faultString})
            except:
                exc_type, exc_value, exc_tb = sys.exc_info()
                results.append({b'faultCode': 1, b'faultString': b'%s:%s' % (exc_type, exc_value)})

        return results

    def _dispatch(self, method, params):
        func = None
        try:
            func = self.funcs[method]
        except KeyError:
            if self.instance is not None:
                if hasattr(self.instance, b'_dispatch'):
                    return self.instance._dispatch(method, params)
                try:
                    func = resolve_dotted_attribute(self.instance, method, self.allow_dotted_names)
                except AttributeError:
                    pass

        if func is not None:
            return func(*params)
        else:
            raise Exception(b'method "%s" is not supported' % method)
            return


class SimpleXMLRPCRequestHandler(BaseHTTPRequestHandler):
    rpc_paths = ('/', '/RPC2')
    encode_threshold = 1400
    wbufsize = -1
    disable_nagle_algorithm = True
    aepattern = re.compile(b'\n                            \\s* ([^\\s;]+) \\s*            #content-coding\n                            (;\\s* q \\s*=\\s* ([0-9\\.]+))? #q\n                            ', re.VERBOSE | re.IGNORECASE)

    def accept_encodings(self):
        r = {}
        ae = self.headers.get(b'Accept-Encoding', b'')
        for e in ae.split(b','):
            match = self.aepattern.match(e)
            if match:
                v = match.group(3)
                v = float(v) if v else 1.0
                r[match.group(1)] = v

        return r

    def is_rpc_path_valid(self):
        if self.rpc_paths:
            return self.path in self.rpc_paths
        else:
            return True

    def do_POST(self):
        if not self.is_rpc_path_valid():
            self.report_404()
            return
        else:
            try:
                max_chunk_size = 10485760
                size_remaining = int(self.headers[b'content-length'])
                L = []
                while size_remaining:
                    chunk_size = min(size_remaining, max_chunk_size)
                    chunk = self.rfile.read(chunk_size)
                    if not chunk:
                        break
                    L.append(chunk)
                    size_remaining -= len(L[(-1)])

                data = (b'').join(L)
                data = self.decode_request_content(data)
                if data is None:
                    return
                response = self.server._marshaled_dispatch(data, getattr(self, b'_dispatch', None), self.path)
            except Exception as e:
                self.send_response(500)
                if hasattr(self.server, b'_send_traceback_header') and self.server._send_traceback_header:
                    self.send_header(b'X-exception', str(e))
                    trace = traceback.format_exc()
                    trace = str(trace.encode(b'ASCII', b'backslashreplace'), b'ASCII')
                    self.send_header(b'X-traceback', trace)
                self.send_header(b'Content-length', b'0')
                self.end_headers()
            else:
                self.send_response(200)
                self.send_header(b'Content-type', b'text/xml')
                if self.encode_threshold is not None:
                    if len(response) > self.encode_threshold:
                        q = self.accept_encodings().get(b'gzip', 0)
                        if q:
                            try:
                                response = gzip_encode(response)
                                self.send_header(b'Content-Encoding', b'gzip')
                            except NotImplementedError:
                                pass

                self.send_header(b'Content-length', str(len(response)))
                self.end_headers()
                self.wfile.write(response)

            return

    def decode_request_content(self, data):
        encoding = self.headers.get(b'content-encoding', b'identity').lower()
        if encoding == b'identity':
            return data
        if encoding == b'gzip':
            try:
                return gzip_decode(data)
            except NotImplementedError:
                self.send_response(501, b'encoding %r not supported' % encoding)
            except ValueError:
                self.send_response(400, b'error decoding gzip content')

        else:
            self.send_response(501, b'encoding %r not supported' % encoding)
        self.send_header(b'Content-length', b'0')
        self.end_headers()

    def report_404(self):
        self.send_response(404)
        response = b'No such page'
        self.send_header(b'Content-type', b'text/plain')
        self.send_header(b'Content-length', str(len(response)))
        self.end_headers()
        self.wfile.write(response)

    def log_request(self, code=b'-', size=b'-'):
        if self.server.logRequests:
            BaseHTTPRequestHandler.log_request(self, code, size)


class SimpleXMLRPCServer(socketserver.TCPServer, SimpleXMLRPCDispatcher):
    allow_reuse_address = True
    _send_traceback_header = False

    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler, logRequests=True, allow_none=False, encoding=None, bind_and_activate=True, use_builtin_types=False):
        self.logRequests = logRequests
        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding, use_builtin_types)
        socketserver.TCPServer.__init__(self, addr, requestHandler, bind_and_activate)
        if fcntl is not None and hasattr(fcntl, b'FD_CLOEXEC'):
            flags = fcntl.fcntl(self.fileno(), fcntl.F_GETFD)
            flags |= fcntl.FD_CLOEXEC
            fcntl.fcntl(self.fileno(), fcntl.F_SETFD, flags)
        return


class MultiPathXMLRPCServer(SimpleXMLRPCServer):

    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler, logRequests=True, allow_none=False, encoding=None, bind_and_activate=True, use_builtin_types=False):
        SimpleXMLRPCServer.__init__(self, addr, requestHandler, logRequests, allow_none, encoding, bind_and_activate, use_builtin_types)
        self.dispatchers = {}
        self.allow_none = allow_none
        self.encoding = encoding or b'utf-8'

    def add_dispatcher(self, path, dispatcher):
        self.dispatchers[path] = dispatcher
        return dispatcher

    def get_dispatcher(self, path):
        return self.dispatchers[path]

    def _marshaled_dispatch(self, data, dispatch_method=None, path=None):
        try:
            response = self.dispatchers[path]._marshaled_dispatch(data, dispatch_method, path)
        except:
            exc_type, exc_value = sys.exc_info()[:2]
            response = dumps(Fault(1, b'%s:%s' % (exc_type, exc_value)), encoding=self.encoding, allow_none=self.allow_none)
            response = response.encode(self.encoding)

        return response


class CGIXMLRPCRequestHandler(SimpleXMLRPCDispatcher):

    def __init__(self, allow_none=False, encoding=None, use_builtin_types=False):
        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding, use_builtin_types)

    def handle_xmlrpc(self, request_text):
        response = self._marshaled_dispatch(request_text)
        print(b'Content-Type: text/xml')
        print(b'Content-Length: %d' % len(response))
        print()
        sys.stdout.flush()
        sys.stdout.buffer.write(response)
        sys.stdout.buffer.flush()

    def handle_get(self):
        code = 400
        message, explain = BaseHTTPRequestHandler.responses[code]
        response = http_server.DEFAULT_ERROR_MESSAGE % {b'code': code, 
           b'message': message, 
           b'explain': explain}
        response = response.encode(b'utf-8')
        print(b'Status: %d %s' % (code, message))
        print(b'Content-Type: %s' % http_server.DEFAULT_ERROR_CONTENT_TYPE)
        print(b'Content-Length: %d' % len(response))
        print()
        sys.stdout.flush()
        sys.stdout.buffer.write(response)
        sys.stdout.buffer.flush()

    def handle_request(self, request_text=None):
        if request_text is None and os.environ.get(b'REQUEST_METHOD', None) == b'GET':
            self.handle_get()
        else:
            try:
                length = int(os.environ.get(b'CONTENT_LENGTH', None))
            except (ValueError, TypeError):
                length = -1

            if request_text is None:
                request_text = sys.stdin.read(length)
            self.handle_xmlrpc(request_text)
        return


class ServerHTMLDoc(pydoc.HTMLDoc):

    def markup(self, text, escape=None, funcs={}, classes={}, methods={}):
        escape = escape or self.escape
        results = []
        here = 0
        pattern = re.compile(b'\\b((http|ftp)://\\S+[\\w/]|RFC[- ]?(\\d+)|PEP[- ]?(\\d+)|(self\\.)?((?:\\w|\\.)+))\\b')
        while 1:
            match = pattern.search(text, here)
            if not match:
                break
            start, end = match.span()
            results.append(escape(text[here:start]))
            all, scheme, rfc, pep, selfdot, name = match.groups()
            if scheme:
                url = escape(all).replace(b'"', b'&quot;')
                results.append(b'<a href="%s">%s</a>' % (url, url))
            elif rfc:
                url = b'http://www.rfc-editor.org/rfc/rfc%d.txt' % int(rfc)
                results.append(b'<a href="%s">%s</a>' % (url, escape(all)))
            elif pep:
                url = b'http://www.python.org/dev/peps/pep-%04d/' % int(pep)
                results.append(b'<a href="%s">%s</a>' % (url, escape(all)))
            elif text[end:end + 1] == b'(':
                results.append(self.namelink(name, methods, funcs, classes))
            elif selfdot:
                results.append(b'self.<strong>%s</strong>' % name)
            else:
                results.append(self.namelink(name, classes))
            here = end

        results.append(escape(text[here:]))
        return (b'').join(results)

    def docroutine(self, object, name, mod=None, funcs={}, classes={}, methods={}, cl=None):
        anchor = (cl and cl.__name__ or b'') + b'-' + name
        note = b''
        title = b'<a name="%s"><strong>%s</strong></a>' % (
         self.escape(anchor), self.escape(name))
        if inspect.ismethod(object):
            args = inspect.getfullargspec(object)
            argspec = inspect.formatargspec(args.args[1:], args.varargs, args.varkw, args.defaults, annotations=args.annotations, formatvalue=self.formatvalue)
        elif inspect.isfunction(object):
            args = inspect.getfullargspec(object)
            argspec = inspect.formatargspec(args.args, args.varargs, args.varkw, args.defaults, annotations=args.annotations, formatvalue=self.formatvalue)
        else:
            argspec = b'(...)'
        if isinstance(object, tuple):
            argspec = object[0] or argspec
            docstring = object[1] or b''
        else:
            docstring = pydoc.getdoc(object)
        decl = title + argspec + (note and self.grey(b'<font face="helvetica, arial">%s</font>' % note))
        doc = self.markup(docstring, self.preformat, funcs, classes, methods)
        doc = doc and b'<dd><tt>%s</tt></dd>' % doc
        return b'<dl><dt>%s</dt>%s</dl>\n' % (decl, doc)

    def docserver(self, server_name, package_documentation, methods):
        fdict = {}
        for key, value in methods.items():
            fdict[key] = b'#-' + key
            fdict[value] = fdict[key]

        server_name = self.escape(server_name)
        head = b'<big><big><strong>%s</strong></big></big>' % server_name
        result = self.heading(head, b'#ffffff', b'#7799ee')
        doc = self.markup(package_documentation, self.preformat, fdict)
        doc = doc and b'<tt>%s</tt>' % doc
        result = result + b'<p>%s</p>\n' % doc
        contents = []
        method_items = sorted(methods.items())
        for key, value in method_items:
            contents.append(self.docroutine(value, key, funcs=fdict))

        result = result + self.bigsection(b'Methods', b'#ffffff', b'#eeaa77', (b'').join(contents))
        return result


class XMLRPCDocGenerator(object):

    def __init__(self):
        self.server_name = b'XML-RPC Server Documentation'
        self.server_documentation = b'This server exports the following methods through the XML-RPC protocol.'
        self.server_title = b'XML-RPC Server Documentation'

    def set_server_title(self, server_title):
        self.server_title = server_title

    def set_server_name(self, server_name):
        self.server_name = server_name

    def set_server_documentation(self, server_documentation):
        self.server_documentation = server_documentation

    def generate_html_documentation(self):
        methods = {}
        for method_name in self.system_listMethods():
            if method_name in self.funcs:
                method = self.funcs[method_name]
            elif self.instance is not None:
                method_info = [
                 None, None]
                if hasattr(self.instance, b'_get_method_argstring'):
                    method_info[0] = self.instance._get_method_argstring(method_name)
                if hasattr(self.instance, b'_methodHelp'):
                    method_info[1] = self.instance._methodHelp(method_name)
                method_info = tuple(method_info)
                if method_info != (None, None):
                    method = method_info
                elif not hasattr(self.instance, b'_dispatch'):
                    try:
                        method = resolve_dotted_attribute(self.instance, method_name)
                    except AttributeError:
                        method = method_info

                else:
                    method = method_info
            methods[method_name] = method

        documenter = ServerHTMLDoc()
        documentation = documenter.docserver(self.server_name, self.server_documentation, methods)
        return documenter.page(self.server_title, documentation)


class DocXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):

    def do_GET(self):
        if not self.is_rpc_path_valid():
            self.report_404()
            return
        response = self.server.generate_html_documentation().encode(b'utf-8')
        self.send_response(200)
        self.send_header(b'Content-type', b'text/html')
        self.send_header(b'Content-length', str(len(response)))
        self.end_headers()
        self.wfile.write(response)


class DocXMLRPCServer(SimpleXMLRPCServer, XMLRPCDocGenerator):

    def __init__(self, addr, requestHandler=DocXMLRPCRequestHandler, logRequests=True, allow_none=False, encoding=None, bind_and_activate=True, use_builtin_types=False):
        SimpleXMLRPCServer.__init__(self, addr, requestHandler, logRequests, allow_none, encoding, bind_and_activate, use_builtin_types)
        XMLRPCDocGenerator.__init__(self)


class DocCGIXMLRPCRequestHandler(CGIXMLRPCRequestHandler, XMLRPCDocGenerator):

    def handle_get(self):
        response = self.generate_html_documentation().encode(b'utf-8')
        print(b'Content-Type: text/html')
        print(b'Content-Length: %d' % len(response))
        print()
        sys.stdout.flush()
        sys.stdout.buffer.write(response)
        sys.stdout.buffer.flush()

    def __init__(self):
        CGIXMLRPCRequestHandler.__init__(self)
        XMLRPCDocGenerator.__init__(self)


if __name__ == b'__main__':
    import datetime

    class ExampleService():

        def getData(self):
            return b'42'

        class currentTime:

            @staticmethod
            def getCurrentTime():
                return datetime.datetime.now()


    server = SimpleXMLRPCServer((b'localhost', 8000))
    server.register_function(pow)
    server.register_function(lambda x, y: x + y, b'add')
    server.register_instance(ExampleService(), allow_dotted_names=True)
    server.register_multicall_functions()
    print(b'Serving XML-RPC on localhost port 8000')
    print(b'It is advisable to run this example server within a secure, closed network.')
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print(b'\nKeyboard interrupt received, exiting.')
        server.server_close()
        sys.exit(0)