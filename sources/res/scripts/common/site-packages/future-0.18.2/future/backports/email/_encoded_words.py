from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
from future.builtins import bytes
from future.builtins import chr
from future.builtins import int
from future.builtins import str
import re, base64, binascii, functools
from string import ascii_letters, digits
from future.backports.email import errors
__all__ = [
 b'decode_q',
 b'encode_q',
 b'decode_b',
 b'encode_b',
 b'len_q',
 b'len_b',
 b'decode',
 b'encode']
_q_byte_subber = functools.partial(re.compile(b'=([a-fA-F0-9]{2})').sub, lambda m: bytes([int(m.group(1), 16)]))

def decode_q(encoded):
    encoded = bytes(encoded.replace(b'_', b' '))
    return (_q_byte_subber(encoded), [])


class _QByteMap(dict):
    safe = bytes(b'-!*+/' + ascii_letters.encode(b'ascii') + digits.encode(b'ascii'))

    def __missing__(self, key):
        if key in self.safe:
            self[key] = chr(key)
        else:
            self[key] = (b'={:02X}').format(key)
        return self[key]


_q_byte_map = _QByteMap()
_q_byte_map[ord(b' ')] = b'_'

def encode_q(bstring):
    return str((b'').join(_q_byte_map[x] for x in bytes(bstring)))


def len_q(bstring):
    return sum(len(_q_byte_map[x]) for x in bytes(bstring))


def decode_b(encoded):
    defects = []
    pad_err = len(encoded) % 4
    if pad_err:
        defects.append(errors.InvalidBase64PaddingDefect())
        padded_encoded = encoded + b'==='[:4 - pad_err]
    else:
        padded_encoded = encoded
    try:
        if not re.match(b'^[A-Za-z0-9+/]*={0,2}$', padded_encoded):
            raise binascii.Error(b'Non-base64 digit found')
        return (
         base64.b64decode(padded_encoded), defects)
    except binascii.Error:
        defects = [
         errors.InvalidBase64CharactersDefect()]
        for i in (0, 1, 2, 3):
            try:
                return (
                 base64.b64decode(encoded + b'=' * i), defects)
            except (binascii.Error, TypeError):
                if i == 0:
                    defects.append(errors.InvalidBase64PaddingDefect())

        else:
            raise AssertionError(b'unexpected binascii.Error')


def encode_b(bstring):
    return base64.b64encode(bstring).decode(b'ascii')


def len_b(bstring):
    groups_of_3, leftover = divmod(len(bstring), 3)
    return groups_of_3 * 4 + (4 if leftover else 0)


_cte_decoders = {b'q': decode_q, 
   b'b': decode_b}

def decode(ew):
    _, charset, cte, cte_string, _ = str(ew).split(b'?')
    charset, _, lang = charset.partition(b'*')
    cte = cte.lower()
    bstring = cte_string.encode(b'ascii', b'surrogateescape')
    bstring, defects = _cte_decoders[cte](bstring)
    try:
        string = bstring.decode(charset)
    except UnicodeError:
        defects.append(errors.UndecodableBytesDefect((b'Encoded word contains bytes not decodable using {} charset').format(charset)))
        string = bstring.decode(charset, b'surrogateescape')
    except LookupError:
        string = bstring.decode(b'ascii', b'surrogateescape')
        if charset.lower() != b'unknown-8bit':
            defects.append(errors.CharsetError((b'Unknown charset {} in encoded word; decoded as unknown bytes').format(charset)))

    return (
     string, charset, lang, defects)


_cte_encoders = {b'q': encode_q, 
   b'b': encode_b}
_cte_encode_length = {b'q': len_q, 
   b'b': len_b}

def encode(string, charset=b'utf-8', encoding=None, lang=b''):
    string = str(string)
    if charset == b'unknown-8bit':
        bstring = string.encode(b'ascii', b'surrogateescape')
    else:
        bstring = string.encode(charset)
    if encoding is None:
        qlen = _cte_encode_length[b'q'](bstring)
        blen = _cte_encode_length[b'b'](bstring)
        encoding = b'q' if qlen - blen < 5 else b'b'
    encoded = _cte_encoders[encoding](bstring)
    if lang:
        lang = b'*' + lang
    return (b'=?{0}{1}?{2}?{3}?=').format(charset, lang, encoding, encoded)