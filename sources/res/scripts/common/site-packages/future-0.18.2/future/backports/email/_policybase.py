from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
from future.builtins import super
from future.builtins import str
from future.utils import with_metaclass
import abc
from future.backports.email import header
from future.backports.email import charset as _charset
from future.backports.email.utils import _has_surrogates
__all__ = [
 b'Policy',
 b'Compat32',
 b'compat32']

class _PolicyBase(object):

    def __init__(self, **kw):
        for name, value in kw.items():
            if hasattr(self, name):
                super(_PolicyBase, self).__setattr__(name, value)
            else:
                raise TypeError((b'{!r} is an invalid keyword argument for {}').format(name, self.__class__.__name__))

    def __repr__(self):
        args = [ (b'{}={!r}').format(name, value) for name, value in self.__dict__.items() ]
        return (b'{}({})').format(self.__class__.__name__, (b', ').join(args))

    def clone(self, **kw):
        newpolicy = self.__class__.__new__(self.__class__)
        for attr, value in self.__dict__.items():
            object.__setattr__(newpolicy, attr, value)

        for attr, value in kw.items():
            if not hasattr(self, attr):
                raise TypeError((b'{!r} is an invalid keyword argument for {}').format(attr, self.__class__.__name__))
            object.__setattr__(newpolicy, attr, value)

        return newpolicy

    def __setattr__(self, name, value):
        if hasattr(self, name):
            msg = b'{!r} object attribute {!r} is read-only'
        else:
            msg = b'{!r} object has no attribute {!r}'
        raise AttributeError(msg.format(self.__class__.__name__, name))

    def __add__(self, other):
        return self.clone(**other.__dict__)


def _append_doc(doc, added_doc):
    doc = doc.rsplit(b'\n', 1)[0]
    added_doc = added_doc.split(b'\n', 1)[1]
    return doc + b'\n' + added_doc


def _extend_docstrings(cls):
    if cls.__doc__ and cls.__doc__.startswith(b'+'):
        cls.__doc__ = _append_doc(cls.__bases__[0].__doc__, cls.__doc__)
    for name, attr in cls.__dict__.items():
        if attr.__doc__ and attr.__doc__.startswith(b'+'):
            for c in (c for base in cls.__bases__ for c in base.mro()):
                doc = getattr(getattr(c, name), b'__doc__')
                if doc:
                    attr.__doc__ = _append_doc(doc, attr.__doc__)
                    break

    return cls


class Policy(with_metaclass(abc.ABCMeta, _PolicyBase)):
    raise_on_defect = False
    linesep = b'\n'
    cte_type = b'8bit'
    max_line_length = 78

    def handle_defect(self, obj, defect):
        if self.raise_on_defect:
            raise defect
        self.register_defect(obj, defect)

    def register_defect(self, obj, defect):
        obj.defects.append(defect)

    def header_max_count(self, name):
        return

    @abc.abstractmethod
    def header_source_parse(self, sourcelines):
        raise NotImplementedError

    @abc.abstractmethod
    def header_store_parse(self, name, value):
        raise NotImplementedError

    @abc.abstractmethod
    def header_fetch_parse(self, name, value):
        raise NotImplementedError

    @abc.abstractmethod
    def fold(self, name, value):
        raise NotImplementedError

    @abc.abstractmethod
    def fold_binary(self, name, value):
        raise NotImplementedError


@_extend_docstrings
class Compat32(Policy):

    def _sanitize_header(self, name, value):
        if not isinstance(value, str):
            return value
        else:
            if _has_surrogates(value):
                return header.Header(value, charset=_charset.UNKNOWN8BIT, header_name=name)
            return value

    def header_source_parse(self, sourcelines):
        name, value = sourcelines[0].split(b':', 1)
        value = value.lstrip(b' \t') + (b'').join(sourcelines[1:])
        return (name, value.rstrip(b'\r\n'))

    def header_store_parse(self, name, value):
        return (
         name, value)

    def header_fetch_parse(self, name, value):
        return self._sanitize_header(name, value)

    def fold(self, name, value):
        return self._fold(name, value, sanitize=True)

    def fold_binary(self, name, value):
        folded = self._fold(name, value, sanitize=self.cte_type == b'7bit')
        return folded.encode(b'ascii', b'surrogateescape')

    def _fold(self, name, value, sanitize):
        parts = []
        parts.append(b'%s: ' % name)
        if isinstance(value, str):
            if _has_surrogates(value):
                if sanitize:
                    h = header.Header(value, charset=_charset.UNKNOWN8BIT, header_name=name)
                else:
                    parts.append(value)
                    h = None
            else:
                h = header.Header(value, header_name=name)
        else:
            h = value
        if h is not None:
            parts.append(h.encode(linesep=self.linesep, maxlinelen=self.max_line_length))
        parts.append(self.linesep)
        return (b'').join(parts)


compat32 = Compat32()