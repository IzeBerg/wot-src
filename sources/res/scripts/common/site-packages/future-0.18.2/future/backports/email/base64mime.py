from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
from future.builtins import range
from future.builtins import bytes
__all__ = [
 b'body_decode',
 b'body_encode',
 b'decode',
 b'decodestring',
 b'header_encode',
 b'header_length']
from base64 import b64encode
from binascii import b2a_base64, a2b_base64
CRLF = b'\r\n'
NL = b'\n'
EMPTYSTRING = b''
MISC_LEN = 7

def header_length(bytearray):
    groups_of_3, leftover = divmod(len(bytearray), 3)
    n = groups_of_3 * 4
    if leftover:
        n += 4
    return n


def header_encode(header_bytes, charset=b'iso-8859-1'):
    if not header_bytes:
        return b''
    if isinstance(header_bytes, str):
        header_bytes = header_bytes.encode(charset)
    encoded = b64encode(header_bytes).decode(b'ascii')
    return b'=?%s?b?%s?=' % (charset, encoded)


def body_encode(s, maxlinelen=76, eol=NL):
    if not s:
        return s
    encvec = []
    max_unencoded = maxlinelen * 3 // 4
    for i in range(0, len(s), max_unencoded):
        enc = b2a_base64(s[i:i + max_unencoded]).decode(b'ascii')
        if enc.endswith(NL) and eol != NL:
            enc = enc[:-1] + eol
        encvec.append(enc)

    return EMPTYSTRING.join(encvec)


def decode(string):
    if not string:
        return bytes()
    else:
        if isinstance(string, str):
            return a2b_base64(string.encode(b'raw-unicode-escape'))
        return a2b_base64(string)


body_decode = decode
decodestring = decode