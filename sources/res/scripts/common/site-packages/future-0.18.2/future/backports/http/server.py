from __future__ import absolute_import, division, print_function, unicode_literals
from future import utils
from future.builtins import *
__version__ = b'0.6'
__all__ = [
 b'HTTPServer', b'BaseHTTPRequestHandler']
from future.backports import html
from future.backports.http import client as http_client
from future.backports.urllib import parse as urllib_parse
from future.backports import socketserver
import io, mimetypes, os, posixpath, select, shutil, socket, sys, time, copy, argparse
DEFAULT_ERROR_MESSAGE = b'<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"\n        "http://www.w3.org/TR/html4/strict.dtd">\n<html>\n    <head>\n        <meta http-equiv="Content-Type" content="text/html;charset=utf-8">\n        <title>Error response</title>\n    </head>\n    <body>\n        <h1>Error response</h1>\n        <p>Error code: %(code)d</p>\n        <p>Message: %(message)s.</p>\n        <p>Error code explanation: %(code)s - %(explain)s.</p>\n    </body>\n</html>\n'
DEFAULT_ERROR_CONTENT_TYPE = b'text/html;charset=utf-8'

def _quote_html(html):
    return html.replace(b'&', b'&amp;').replace(b'<', b'&lt;').replace(b'>', b'&gt;')


class HTTPServer(socketserver.TCPServer):
    allow_reuse_address = 1

    def server_bind(self):
        socketserver.TCPServer.server_bind(self)
        host, port = self.socket.getsockname()[:2]
        self.server_name = socket.getfqdn(host)
        self.server_port = port


class BaseHTTPRequestHandler(socketserver.StreamRequestHandler):
    sys_version = b'Python/' + sys.version.split()[0]
    server_version = b'BaseHTTP/' + __version__
    error_message_format = DEFAULT_ERROR_MESSAGE
    error_content_type = DEFAULT_ERROR_CONTENT_TYPE
    default_request_version = b'HTTP/0.9'

    def parse_request(self):
        self.command = None
        self.request_version = version = self.default_request_version
        self.close_connection = 1
        requestline = str(self.raw_requestline, b'iso-8859-1')
        requestline = requestline.rstrip(b'\r\n')
        self.requestline = requestline
        words = requestline.split()
        if len(words) == 3:
            command, path, version = words
            if version[:5] != b'HTTP/':
                self.send_error(400, b'Bad request version (%r)' % version)
                return False
            try:
                base_version_number = version.split(b'/', 1)[1]
                version_number = base_version_number.split(b'.')
                if len(version_number) != 2:
                    raise ValueError
                version_number = (
                 int(version_number[0]), int(version_number[1]))
            except (ValueError, IndexError):
                self.send_error(400, b'Bad request version (%r)' % version)
                return False

            if version_number >= (1, 1) and self.protocol_version >= b'HTTP/1.1':
                self.close_connection = 0
            if version_number >= (2, 0):
                self.send_error(505, b'Invalid HTTP Version (%s)' % base_version_number)
                return False
        else:
            if len(words) == 2:
                command, path = words
                self.close_connection = 1
                if command != b'GET':
                    self.send_error(400, b'Bad HTTP/0.9 request type (%r)' % command)
                    return False
            else:
                if not words:
                    return False
                else:
                    self.send_error(400, b'Bad request syntax (%r)' % requestline)
                    return False

            self.command, self.path, self.request_version = command, path, version
            try:
                self.headers = http_client.parse_headers(self.rfile, _class=self.MessageClass)
            except http_client.LineTooLong:
                self.send_error(400, b'Line too long')
                return False

        conntype = self.headers.get(b'Connection', b'')
        if conntype.lower() == b'close':
            self.close_connection = 1
        elif conntype.lower() == b'keep-alive' and self.protocol_version >= b'HTTP/1.1':
            self.close_connection = 0
        expect = self.headers.get(b'Expect', b'')
        if expect.lower() == b'100-continue' and self.protocol_version >= b'HTTP/1.1' and self.request_version >= b'HTTP/1.1':
            if not self.handle_expect_100():
                return False
        return True

    def handle_expect_100(self):
        self.send_response_only(100)
        self.flush_headers()
        return True

    def handle_one_request(self):
        try:
            self.raw_requestline = self.rfile.readline(65537)
            if len(self.raw_requestline) > 65536:
                self.requestline = b''
                self.request_version = b''
                self.command = b''
                self.send_error(414)
                return
            if not self.raw_requestline:
                self.close_connection = 1
                return
            if not self.parse_request():
                return
            mname = b'do_' + self.command
            if not hasattr(self, mname):
                self.send_error(501, b'Unsupported method (%r)' % self.command)
                return
            method = getattr(self, mname)
            method()
            self.wfile.flush()
        except socket.timeout as e:
            self.log_error(b'Request timed out: %r', e)
            self.close_connection = 1
            return

    def handle(self):
        self.close_connection = 1
        self.handle_one_request()
        while not self.close_connection:
            self.handle_one_request()

    def send_error(self, code, message=None):
        try:
            shortmsg, longmsg = self.responses[code]
        except KeyError:
            shortmsg, longmsg = ('???', '???')

        if message is None:
            message = shortmsg
        explain = longmsg
        self.log_error(b'code %d, message %s', code, message)
        content = self.error_message_format % {b'code': code, b'message': _quote_html(message), b'explain': explain}
        self.send_response(code, message)
        self.send_header(b'Content-Type', self.error_content_type)
        self.send_header(b'Connection', b'close')
        self.end_headers()
        if self.command != b'HEAD' and code >= 200 and code not in (204, 304):
            self.wfile.write(content.encode(b'UTF-8', b'replace'))
        return

    def send_response(self, code, message=None):
        self.log_request(code)
        self.send_response_only(code, message)
        self.send_header(b'Server', self.version_string())
        self.send_header(b'Date', self.date_time_string())

    def send_response_only(self, code, message=None):
        if message is None:
            if code in self.responses:
                message = self.responses[code][0]
            else:
                message = b''
        if self.request_version != b'HTTP/0.9':
            if not hasattr(self, b'_headers_buffer'):
                self._headers_buffer = []
            self._headers_buffer.append((b'%s %d %s\r\n' % (
             self.protocol_version, code, message)).encode(b'latin-1', b'strict'))
        return

    def send_header(self, keyword, value):
        if self.request_version != b'HTTP/0.9':
            if not hasattr(self, b'_headers_buffer'):
                self._headers_buffer = []
            self._headers_buffer.append((b'%s: %s\r\n' % (keyword, value)).encode(b'latin-1', b'strict'))
        if keyword.lower() == b'connection':
            if value.lower() == b'close':
                self.close_connection = 1
            elif value.lower() == b'keep-alive':
                self.close_connection = 0

    def end_headers(self):
        if self.request_version != b'HTTP/0.9':
            self._headers_buffer.append(b'\r\n')
            self.flush_headers()

    def flush_headers(self):
        if hasattr(self, b'_headers_buffer'):
            self.wfile.write((b'').join(self._headers_buffer))
            self._headers_buffer = []

    def log_request(self, code=b'-', size=b'-'):
        self.log_message(b'"%s" %s %s', self.requestline, str(code), str(size))

    def log_error(self, format, *args):
        self.log_message(format, *args)

    def log_message(self, format, *args):
        sys.stderr.write(b'%s - - [%s] %s\n' % (
         self.address_string(),
         self.log_date_time_string(),
         format % args))

    def version_string(self):
        return self.server_version + b' ' + self.sys_version

    def date_time_string(self, timestamp=None):
        if timestamp is None:
            timestamp = time.time()
        year, month, day, hh, mm, ss, wd, y, z = time.gmtime(timestamp)
        s = b'%s, %02d %3s %4d %02d:%02d:%02d GMT' % (
         self.weekdayname[wd],
         day, self.monthname[month], year,
         hh, mm, ss)
        return s

    def log_date_time_string(self):
        now = time.time()
        year, month, day, hh, mm, ss, x, y, z = time.localtime(now)
        s = b'%02d/%3s/%04d %02d:%02d:%02d' % (
         day, self.monthname[month], year, hh, mm, ss)
        return s

    weekdayname = [
     b'Mon', b'Tue', b'Wed', b'Thu', b'Fri', b'Sat', b'Sun']
    monthname = [
     None,
     b'Jan', b'Feb', b'Mar', b'Apr', b'May', b'Jun',
     b'Jul', b'Aug', b'Sep', b'Oct', b'Nov', b'Dec']

    def address_string(self):
        return self.client_address[0]

    protocol_version = b'HTTP/1.0'
    MessageClass = http_client.HTTPMessage
    responses = {100: ('Continue', 'Request received, please continue'), 
       101: ('Switching Protocols', 'Switching to new protocol; obey Upgrade header'), 
       200: ('OK', 'Request fulfilled, document follows'), 
       201: ('Created', 'Document created, URL follows'), 
       202: ('Accepted', 'Request accepted, processing continues off-line'), 
       203: ('Non-Authoritative Information', 'Request fulfilled from cache'), 
       204: ('No Content', 'Request fulfilled, nothing follows'), 
       205: ('Reset Content', 'Clear input form for further input.'), 
       206: ('Partial Content', 'Partial content follows.'), 
       300: ('Multiple Choices', 'Object has several resources -- see URI list'), 
       301: ('Moved Permanently', 'Object moved permanently -- see URI list'), 
       302: ('Found', 'Object moved temporarily -- see URI list'), 
       303: ('See Other', 'Object moved -- see Method and URL list'), 
       304: ('Not Modified', 'Document has not changed since given time'), 
       305: ('Use Proxy', 'You must use proxy specified in Location to access this resource.'), 
       307: ('Temporary Redirect', 'Object moved temporarily -- see URI list'), 
       400: ('Bad Request', 'Bad request syntax or unsupported method'), 
       401: ('Unauthorized', 'No permission -- see authorization schemes'), 
       402: ('Payment Required', 'No payment -- see charging schemes'), 
       403: ('Forbidden', 'Request forbidden -- authorization will not help'), 
       404: ('Not Found', 'Nothing matches the given URI'), 
       405: ('Method Not Allowed', 'Specified method is invalid for this resource.'), 
       406: ('Not Acceptable', 'URI not available in preferred format.'), 
       407: ('Proxy Authentication Required', 'You must authenticate with this proxy before proceeding.'), 
       408: ('Request Timeout', 'Request timed out; try again later.'), 
       409: ('Conflict', 'Request conflict.'), 
       410: ('Gone', 'URI no longer exists and has been permanently removed.'), 
       411: ('Length Required', 'Client must specify Content-Length.'), 
       412: ('Precondition Failed', 'Precondition in headers is false.'), 
       413: ('Request Entity Too Large', 'Entity is too large.'), 
       414: ('Request-URI Too Long', 'URI is too long.'), 
       415: ('Unsupported Media Type', 'Entity body in unsupported format.'), 
       416: ('Requested Range Not Satisfiable', 'Cannot satisfy request range.'), 
       417: ('Expectation Failed', 'Expect condition could not be satisfied.'), 
       428: ('Precondition Required', 'The origin server requires the request to be conditional.'), 
       429: ('Too Many Requests', 'The user has sent too many requests in a given amount of time ("rate limiting").'), 
       431: ('Request Header Fields Too Large', 'The server is unwilling to process the request because its header fields are too large.'), 
       500: ('Internal Server Error', 'Server got itself in trouble'), 
       501: ('Not Implemented', 'Server does not support this operation'), 
       502: ('Bad Gateway', 'Invalid responses from another server/proxy.'), 
       503: ('Service Unavailable', 'The server cannot process the request due to a high load'), 
       504: ('Gateway Timeout', 'The gateway server did not receive a timely response'), 
       505: ('HTTP Version Not Supported', 'Cannot fulfill request.'), 
       511: ('Network Authentication Required', 'The client needs to authenticate to gain network access.')}


class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    server_version = b'SimpleHTTP/' + __version__

    def do_GET(self):
        f = self.send_head()
        if f:
            self.copyfile(f, self.wfile)
            f.close()

    def do_HEAD(self):
        f = self.send_head()
        if f:
            f.close()

    def send_head(self):
        path = self.translate_path(self.path)
        f = None
        if os.path.isdir(path):
            if not self.path.endswith(b'/'):
                self.send_response(301)
                self.send_header(b'Location', self.path + b'/')
                self.end_headers()
                return
            for index in ('index.html', 'index.htm'):
                index = os.path.join(path, index)
                if os.path.exists(index):
                    path = index
                    break
            else:
                return self.list_directory(path)

        ctype = self.guess_type(path)
        try:
            f = open(path, b'rb')
        except IOError:
            self.send_error(404, b'File not found')
            return

        self.send_response(200)
        self.send_header(b'Content-type', ctype)
        fs = os.fstat(f.fileno())
        self.send_header(b'Content-Length', str(fs[6]))
        self.send_header(b'Last-Modified', self.date_time_string(fs.st_mtime))
        self.end_headers()
        return f

    def list_directory(self, path):
        try:
            list = os.listdir(path)
        except os.error:
            self.send_error(404, b'No permission to list directory')
            return

        list.sort(key=lambda a: a.lower())
        r = []
        displaypath = html.escape(urllib_parse.unquote(self.path))
        enc = sys.getfilesystemencoding()
        title = b'Directory listing for %s' % displaypath
        r.append(b'<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">')
        r.append(b'<html>\n<head>')
        r.append(b'<meta http-equiv="Content-Type" content="text/html; charset=%s">' % enc)
        r.append(b'<title>%s</title>\n</head>' % title)
        r.append(b'<body>\n<h1>%s</h1>' % title)
        r.append(b'<hr>\n<ul>')
        for name in list:
            fullname = os.path.join(path, name)
            displayname = linkname = name
            if os.path.isdir(fullname):
                displayname = name + b'/'
                linkname = name + b'/'
            if os.path.islink(fullname):
                displayname = name + b'@'
            r.append(b'<li><a href="%s">%s</a></li>' % (
             urllib_parse.quote(linkname), html.escape(displayname)))

        r.append(b'</ul>\n<hr>\n</body>\n</html>\n')
        encoded = (b'\n').join(r).encode(enc)
        f = io.BytesIO()
        f.write(encoded)
        f.seek(0)
        self.send_response(200)
        self.send_header(b'Content-type', b'text/html; charset=%s' % enc)
        self.send_header(b'Content-Length', str(len(encoded)))
        self.end_headers()
        return f

    def translate_path(self, path):
        path = path.split(b'?', 1)[0]
        path = path.split(b'#', 1)[0]
        path = posixpath.normpath(urllib_parse.unquote(path))
        words = path.split(b'/')
        words = filter(None, words)
        path = os.getcwd()
        for word in words:
            drive, word = os.path.splitdrive(word)
            head, word = os.path.split(word)
            if word in (os.curdir, os.pardir):
                continue
            path = os.path.join(path, word)

        return path

    def copyfile(self, source, outputfile):
        shutil.copyfileobj(source, outputfile)

    def guess_type(self, path):
        base, ext = posixpath.splitext(path)
        if ext in self.extensions_map:
            return self.extensions_map[ext]
        else:
            ext = ext.lower()
            if ext in self.extensions_map:
                return self.extensions_map[ext]
            return self.extensions_map[b'']

    if not mimetypes.inited:
        mimetypes.init()
    extensions_map = mimetypes.types_map.copy()
    extensions_map.update({b'': b'application/octet-stream', 
       b'.py': b'text/plain', 
       b'.c': b'text/plain', 
       b'.h': b'text/plain'})


def _url_collapse_path(path):
    path_parts = path.split(b'/')
    head_parts = []
    for part in path_parts[:-1]:
        if part == b'..':
            head_parts.pop()
        elif part and part != b'.':
            head_parts.append(part)

    if path_parts:
        tail_part = path_parts.pop()
        if tail_part:
            if tail_part == b'..':
                head_parts.pop()
                tail_part = b''
            elif tail_part == b'.':
                tail_part = b''
    else:
        tail_part = b''
    splitpath = (b'/' + (b'/').join(head_parts), tail_part)
    collapsed_path = (b'/').join(splitpath)
    return collapsed_path


nobody = None

def nobody_uid():
    global nobody
    if nobody:
        return nobody
    try:
        import pwd
    except ImportError:
        return -1

    try:
        nobody = pwd.getpwnam(b'nobody')[2]
    except KeyError:
        nobody = 1 + max(x[2] for x in pwd.getpwall())

    return nobody


def executable(path):
    return os.access(path, os.X_OK)


class CGIHTTPRequestHandler(SimpleHTTPRequestHandler):
    have_fork = hasattr(os, b'fork')
    rbufsize = 0

    def do_POST(self):
        if self.is_cgi():
            self.run_cgi()
        else:
            self.send_error(501, b'Can only POST to CGI scripts')

    def send_head(self):
        if self.is_cgi():
            return self.run_cgi()
        else:
            return SimpleHTTPRequestHandler.send_head(self)

    def is_cgi(self):
        collapsed_path = _url_collapse_path(self.path)
        dir_sep = collapsed_path.find(b'/', 1)
        head, tail = collapsed_path[:dir_sep], collapsed_path[dir_sep + 1:]
        if head in self.cgi_directories:
            self.cgi_info = (
             head, tail)
            return True
        return False

    cgi_directories = [
     b'/cgi-bin', b'/htbin']

    def is_executable(self, path):
        return executable(path)

    def is_python(self, path):
        head, tail = os.path.splitext(path)
        return tail.lower() in ('.py', '.pyw')

    def run_cgi(self):
        path = self.path
        dir, rest = self.cgi_info
        i = path.find(b'/', len(dir) + 1)
        while i >= 0:
            nextdir = path[:i]
            nextrest = path[i + 1:]
            scriptdir = self.translate_path(nextdir)
            if os.path.isdir(scriptdir):
                dir, rest = nextdir, nextrest
                i = path.find(b'/', len(dir) + 1)
            else:
                break

        i = rest.rfind(b'?')
        if i >= 0:
            rest, query = rest[:i], rest[i + 1:]
        else:
            query = b''
        i = rest.find(b'/')
        if i >= 0:
            script, rest = rest[:i], rest[i:]
        else:
            script, rest = rest, b''
        scriptname = dir + b'/' + script
        scriptfile = self.translate_path(scriptname)
        if not os.path.exists(scriptfile):
            self.send_error(404, b'No such CGI script (%r)' % scriptname)
            return
        else:
            if not os.path.isfile(scriptfile):
                self.send_error(403, b'CGI script is not a plain file (%r)' % scriptname)
                return
            ispy = self.is_python(scriptname)
            if self.have_fork or not ispy:
                if not self.is_executable(scriptfile):
                    self.send_error(403, b'CGI script is not executable (%r)' % scriptname)
                    return
            env = copy.deepcopy(os.environ)
            env[b'SERVER_SOFTWARE'] = self.version_string()
            env[b'SERVER_NAME'] = self.server.server_name
            env[b'GATEWAY_INTERFACE'] = b'CGI/1.1'
            env[b'SERVER_PROTOCOL'] = self.protocol_version
            env[b'SERVER_PORT'] = str(self.server.server_port)
            env[b'REQUEST_METHOD'] = self.command
            uqrest = urllib_parse.unquote(rest)
            env[b'PATH_INFO'] = uqrest
            env[b'PATH_TRANSLATED'] = self.translate_path(uqrest)
            env[b'SCRIPT_NAME'] = scriptname
            if query:
                env[b'QUERY_STRING'] = query
            env[b'REMOTE_ADDR'] = self.client_address[0]
            authorization = self.headers.get(b'authorization')
            if authorization:
                authorization = authorization.split()
                if len(authorization) == 2:
                    import base64, binascii
                    env[b'AUTH_TYPE'] = authorization[0]
                    if authorization[0].lower() == b'basic':
                        try:
                            authorization = authorization[1].encode(b'ascii')
                            if utils.PY3:
                                authorization = base64.decodebytes(authorization).decode(b'ascii')
                            else:
                                authorization = base64.decodestring(authorization).decode(b'ascii')
                        except (binascii.Error, UnicodeError):
                            pass
                        else:
                            authorization = authorization.split(b':')
                            if len(authorization) == 2:
                                env[b'REMOTE_USER'] = authorization[0]
            if self.headers.get(b'content-type') is None:
                env[b'CONTENT_TYPE'] = self.headers.get_content_type()
            else:
                env[b'CONTENT_TYPE'] = self.headers[b'content-type']
            length = self.headers.get(b'content-length')
            if length:
                env[b'CONTENT_LENGTH'] = length
            referer = self.headers.get(b'referer')
            if referer:
                env[b'HTTP_REFERER'] = referer
            accept = []
            for line in self.headers.getallmatchingheaders(b'accept'):
                if line[:1] in b'\t\n\r ':
                    accept.append(line.strip())
                else:
                    accept = accept + line[7:].split(b',')

            env[b'HTTP_ACCEPT'] = (b',').join(accept)
            ua = self.headers.get(b'user-agent')
            if ua:
                env[b'HTTP_USER_AGENT'] = ua
            co = filter(None, self.headers.get_all(b'cookie', []))
            cookie_str = (b', ').join(co)
            if cookie_str:
                env[b'HTTP_COOKIE'] = cookie_str
            for k in ('QUERY_STRING', 'REMOTE_HOST', 'CONTENT_LENGTH', 'HTTP_USER_AGENT',
                      'HTTP_COOKIE', 'HTTP_REFERER'):
                env.setdefault(k, b'')

            self.send_response(200, b'Script output follows')
            self.flush_headers()
            decoded_query = query.replace(b'+', b' ')
            if self.have_fork:
                args = [script]
                if b'=' not in decoded_query:
                    args.append(decoded_query)
                nobody = nobody_uid()
                self.wfile.flush()
                pid = os.fork()
                if pid != 0:
                    pid, sts = os.waitpid(pid, 0)
                    while select.select([self.rfile], [], [], 0)[0]:
                        if not self.rfile.read(1):
                            break

                    if sts:
                        self.log_error(b'CGI script exit status %#x', sts)
                    return
                try:
                    try:
                        os.setuid(nobody)
                    except os.error:
                        pass

                    os.dup2(self.rfile.fileno(), 0)
                    os.dup2(self.wfile.fileno(), 1)
                    os.execve(scriptfile, args, env)
                except:
                    self.server.handle_error(self.request, self.client_address)
                    os._exit(127)

            else:
                import subprocess
                cmdline = [
                 scriptfile]
                if self.is_python(scriptfile):
                    interp = sys.executable
                    if interp.lower().endswith(b'w.exe'):
                        interp = interp[:-5] + interp[-4:]
                    cmdline = [
                     interp, b'-u'] + cmdline
                if b'=' not in query:
                    cmdline.append(query)
                self.log_message(b'command: %s', subprocess.list2cmdline(cmdline))
                try:
                    nbytes = int(length)
                except (TypeError, ValueError):
                    nbytes = 0

                p = subprocess.Popen(cmdline, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)
                if self.command.lower() == b'post' and nbytes > 0:
                    data = self.rfile.read(nbytes)
                else:
                    data = None
                while select.select([self.rfile._sock], [], [], 0)[0]:
                    if not self.rfile._sock.recv(1):
                        break

                stdout, stderr = p.communicate(data)
                self.wfile.write(stdout)
                if stderr:
                    self.log_error(b'%s', stderr)
                p.stderr.close()
                p.stdout.close()
                status = p.returncode
                if status:
                    self.log_error(b'CGI script exit status %#x', status)
                else:
                    self.log_message(b'CGI script exited OK')
            return


def test(HandlerClass=BaseHTTPRequestHandler, ServerClass=HTTPServer, protocol=b'HTTP/1.0', port=8000):
    server_address = (
     b'', port)
    HandlerClass.protocol_version = protocol
    httpd = ServerClass(server_address, HandlerClass)
    sa = httpd.socket.getsockname()
    print(b'Serving HTTP on', sa[0], b'port', sa[1], b'...')
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print(b'\nKeyboard interrupt received, exiting.')
        httpd.server_close()
        sys.exit(0)


if __name__ == b'__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(b'--cgi', action=b'store_true', help=b'Run as CGI Server')
    parser.add_argument(b'port', action=b'store', default=8000, type=int, nargs=b'?', help=b'Specify alternate port [default: 8000]')
    args = parser.parse_args()
    if args.cgi:
        test(HandlerClass=CGIHTTPRequestHandler, port=args.port)
    else:
        test(HandlerClass=SimpleHTTPRequestHandler, port=args.port)