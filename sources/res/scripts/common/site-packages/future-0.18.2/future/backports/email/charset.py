from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
from future.builtins import str
from future.builtins import next
__all__ = [
 b'Charset',
 b'add_alias',
 b'add_charset',
 b'add_codec']
from functools import partial
from future.backports import email
from future.backports.email import errors
from future.backports.email.encoders import encode_7or8bit
QP = 1
BASE64 = 2
SHORTEST = 3
RFC2047_CHROME_LEN = 7
DEFAULT_CHARSET = b'us-ascii'
UNKNOWN8BIT = b'unknown-8bit'
EMPTYSTRING = b''
CHARSETS = {b'iso-8859-1': (
                 QP, QP, None), 
   b'iso-8859-2': (
                 QP, QP, None), 
   b'iso-8859-3': (
                 QP, QP, None), 
   b'iso-8859-4': (
                 QP, QP, None), 
   b'iso-8859-9': (
                 QP, QP, None), 
   b'iso-8859-10': (
                  QP, QP, None), 
   b'iso-8859-13': (
                  QP, QP, None), 
   b'iso-8859-14': (
                  QP, QP, None), 
   b'iso-8859-15': (
                  QP, QP, None), 
   b'iso-8859-16': (
                  QP, QP, None), 
   b'windows-1252': (
                   QP, QP, None), 
   b'viscii': (
             QP, QP, None), 
   b'us-ascii': (None, None, None), 
   b'big5': (
           BASE64, BASE64, None), 
   b'gb2312': (
             BASE64, BASE64, None), 
   b'euc-jp': (
             BASE64, None, b'iso-2022-jp'), 
   b'shift_jis': (
                BASE64, None, b'iso-2022-jp'), 
   b'iso-2022-jp': (
                  BASE64, None, None), 
   b'koi8-r': (
             BASE64, BASE64, None), 
   b'utf-8': (
            SHORTEST, BASE64, b'utf-8')}
ALIASES = {b'latin_1': b'iso-8859-1', 
   b'latin-1': b'iso-8859-1', 
   b'latin_2': b'iso-8859-2', 
   b'latin-2': b'iso-8859-2', 
   b'latin_3': b'iso-8859-3', 
   b'latin-3': b'iso-8859-3', 
   b'latin_4': b'iso-8859-4', 
   b'latin-4': b'iso-8859-4', 
   b'latin_5': b'iso-8859-9', 
   b'latin-5': b'iso-8859-9', 
   b'latin_6': b'iso-8859-10', 
   b'latin-6': b'iso-8859-10', 
   b'latin_7': b'iso-8859-13', 
   b'latin-7': b'iso-8859-13', 
   b'latin_8': b'iso-8859-14', 
   b'latin-8': b'iso-8859-14', 
   b'latin_9': b'iso-8859-15', 
   b'latin-9': b'iso-8859-15', 
   b'latin_10': b'iso-8859-16', 
   b'latin-10': b'iso-8859-16', 
   b'cp949': b'ks_c_5601-1987', 
   b'euc_jp': b'euc-jp', 
   b'euc_kr': b'euc-kr', 
   b'ascii': b'us-ascii'}
CODEC_MAP = {b'gb2312': b'eucgb2312_cn', 
   b'big5': b'big5_tw', 
   b'us-ascii': None}

def add_charset(charset, header_enc=None, body_enc=None, output_charset=None):
    if body_enc == SHORTEST:
        raise ValueError(b'SHORTEST not allowed for body_enc')
    CHARSETS[charset] = (
     header_enc, body_enc, output_charset)


def add_alias(alias, canonical):
    ALIASES[alias] = canonical


def add_codec(charset, codecname):
    CODEC_MAP[charset] = codecname


def _encode(string, codec):
    string = str(string)
    if codec == UNKNOWN8BIT:
        return string.encode(b'ascii', b'surrogateescape')
    else:
        return string.encode(codec)


class Charset(object):

    def __init__(self, input_charset=DEFAULT_CHARSET):
        try:
            if isinstance(input_charset, str):
                input_charset.encode(b'ascii')
            else:
                input_charset = str(input_charset, b'ascii')
        except UnicodeError:
            raise errors.CharsetError(input_charset)

        input_charset = input_charset.lower()
        self.input_charset = ALIASES.get(input_charset, input_charset)
        henc, benc, conv = CHARSETS.get(self.input_charset, (
         SHORTEST, BASE64, None))
        if not conv:
            conv = self.input_charset
        self.header_encoding = henc
        self.body_encoding = benc
        self.output_charset = ALIASES.get(conv, conv)
        self.input_codec = CODEC_MAP.get(self.input_charset, self.input_charset)
        self.output_codec = CODEC_MAP.get(self.output_charset, self.output_charset)
        return

    def __str__(self):
        return self.input_charset.lower()

    __repr__ = __str__

    def __eq__(self, other):
        return str(self) == str(other).lower()

    def __ne__(self, other):
        return not self.__eq__(other)

    def get_body_encoding(self):
        if self.body_encoding == QP:
            return b'quoted-printable'
        else:
            if self.body_encoding == BASE64:
                return b'base64'
            return encode_7or8bit

    def get_output_charset(self):
        return self.output_charset or self.input_charset

    def header_encode(self, string):
        codec = self.output_codec or b'us-ascii'
        header_bytes = _encode(string, codec)
        encoder_module = self._get_encoder(header_bytes)
        if encoder_module is None:
            return string
        else:
            return encoder_module.header_encode(header_bytes, codec)

    def header_encode_lines(self, string, maxlengths):
        codec = self.output_codec or b'us-ascii'
        header_bytes = _encode(string, codec)
        encoder_module = self._get_encoder(header_bytes)
        encoder = partial(encoder_module.header_encode, charset=codec)
        charset = self.get_output_charset()
        extra = len(charset) + RFC2047_CHROME_LEN
        lines = []
        current_line = []
        maxlen = next(maxlengths) - extra
        for character in string:
            current_line.append(character)
            this_line = EMPTYSTRING.join(current_line)
            length = encoder_module.header_length(_encode(this_line, charset))
            if length > maxlen:
                current_line.pop()
                if not lines and not current_line:
                    lines.append(None)
                else:
                    separator = b' ' if lines else b''
                    joined_line = EMPTYSTRING.join(current_line)
                    header_bytes = _encode(joined_line, codec)
                    lines.append(encoder(header_bytes))
                current_line = [
                 character]
                maxlen = next(maxlengths) - extra

        joined_line = EMPTYSTRING.join(current_line)
        header_bytes = _encode(joined_line, codec)
        lines.append(encoder(header_bytes))
        return lines

    def _get_encoder(self, header_bytes):
        if self.header_encoding == BASE64:
            return email.base64mime
        else:
            if self.header_encoding == QP:
                return email.quoprimime
            if self.header_encoding == SHORTEST:
                len64 = email.base64mime.header_length(header_bytes)
                lenqp = email.quoprimime.header_length(header_bytes)
                if len64 < lenqp:
                    return email.base64mime
                return email.quoprimime
            else:
                return
            return

    def body_encode(self, string):
        if not string:
            return string
        else:
            if self.body_encoding is BASE64:
                if isinstance(string, str):
                    string = string.encode(self.output_charset)
                return email.base64mime.body_encode(string)
            if self.body_encoding is QP:
                if isinstance(string, str):
                    string = string.encode(self.output_charset)
                string = string.decode(b'latin1')
                return email.quoprimime.body_encode(string)
            if isinstance(string, str):
                string = string.encode(self.output_charset).decode(b'ascii')
            return string