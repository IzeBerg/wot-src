from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
from future import utils
from future.builtins import bytes, int, str
__all__ = [
 b'collapse_rfc2231_value',
 b'decode_params',
 b'decode_rfc2231',
 b'encode_rfc2231',
 b'formataddr',
 b'formatdate',
 b'format_datetime',
 b'getaddresses',
 b'make_msgid',
 b'mktime_tz',
 b'parseaddr',
 b'parsedate',
 b'parsedate_tz',
 b'parsedate_to_datetime',
 b'unquote']
import os, re
if utils.PY2:
    re.ASCII = 0
import time, base64, random, socket
from future.backports import datetime
from future.backports.urllib.parse import quote as url_quote, unquote as url_unquote
import warnings
from io import StringIO
from future.backports.email._parseaddr import quote
from future.backports.email._parseaddr import AddressList as _AddressList
from future.backports.email._parseaddr import mktime_tz
from future.backports.email._parseaddr import parsedate, parsedate_tz, _parsedate_tz
from quopri import decodestring as _qdecode
from future.backports.email.encoders import _bencode, _qencode
from future.backports.email.charset import Charset
COMMASPACE = b', '
EMPTYSTRING = b''
UEMPTYSTRING = b''
CRLF = b'\r\n'
TICK = b"'"
specialsre = re.compile(b'[][\\\\()<>@,:;".]')
escapesre = re.compile(b'[\\\\"]')
_has_surrogates = re.compile(b'([^-]|\\A)[-]([^-]|\\Z)').search

def _sanitize(string):
    original_bytes = string.encode(b'ascii', b'surrogateescape')
    return original_bytes.decode(b'ascii', b'replace')


def formataddr(pair, charset=b'utf-8'):
    name, address = pair
    address.encode(b'ascii')
    if name:
        try:
            name.encode(b'ascii')
        except UnicodeEncodeError:
            if isinstance(charset, str):
                charset = Charset(charset)
            encoded_name = charset.header_encode(name)
            return b'%s <%s>' % (encoded_name, address)

        quotes = b''
        if specialsre.search(name):
            quotes = b'"'
        name = escapesre.sub(b'\\\\\\g<0>', name)
        return b'%s%s%s <%s>' % (quotes, name, quotes, address)
    return address


def getaddresses(fieldvalues):
    all = COMMASPACE.join(fieldvalues)
    a = _AddressList(all)
    return a.addresslist


ecre = re.compile(b'\n  =\\?                   # literal =?\n  (?P<charset>[^?]*?)   # non-greedy up to the next ? is the charset\n  \\?                    # literal ?\n  (?P<encoding>[qb])    # either a "q" or a "b", case insensitive\n  \\?                    # literal ?\n  (?P<atom>.*?)         # non-greedy up to the next ?= is the atom\n  \\?=                   # literal ?=\n  ', re.VERBOSE | re.IGNORECASE)

def _format_timetuple_and_zone(timetuple, zone):
    return b'%s, %02d %s %04d %02d:%02d:%02d %s' % (
     [
      b'Mon', b'Tue', b'Wed', b'Thu', b'Fri', b'Sat', b'Sun'][timetuple[6]],
     timetuple[2],
     [
      b'Jan', b'Feb', b'Mar', b'Apr', b'May', b'Jun',
      b'Jul', b'Aug', b'Sep', b'Oct', b'Nov', b'Dec'][(timetuple[1] - 1)],
     timetuple[0], timetuple[3], timetuple[4], timetuple[5],
     zone)


def formatdate(timeval=None, localtime=False, usegmt=False):
    if timeval is None:
        timeval = time.time()
    if localtime:
        now = time.localtime(timeval)
        if time.daylight and now[(-1)]:
            offset = time.altzone
        else:
            offset = time.timezone
        hours, minutes = divmod(abs(offset), 3600)
        if offset > 0:
            sign = b'-'
        else:
            sign = b'+'
        zone = b'%s%02d%02d' % (sign, hours, minutes // 60)
    else:
        now = time.gmtime(timeval)
        if usegmt:
            zone = b'GMT'
        else:
            zone = b'-0000'
    return _format_timetuple_and_zone(now, zone)


def format_datetime(dt, usegmt=False):
    now = dt.timetuple()
    if usegmt:
        if dt.tzinfo is None or dt.tzinfo != datetime.timezone.utc:
            raise ValueError(b'usegmt option requires a UTC datetime')
        zone = b'GMT'
    elif dt.tzinfo is None:
        zone = b'-0000'
    else:
        zone = dt.strftime(b'%z')
    return _format_timetuple_and_zone(now, zone)


def make_msgid(idstring=None, domain=None):
    timeval = time.time()
    utcdate = time.strftime(b'%Y%m%d%H%M%S', time.gmtime(timeval))
    pid = os.getpid()
    randint = random.randrange(100000)
    if idstring is None:
        idstring = b''
    else:
        idstring = b'.' + idstring
    if domain is None:
        domain = socket.getfqdn()
    msgid = b'<%s.%s.%s%s@%s>' % (utcdate, pid, randint, idstring, domain)
    return msgid


def parsedate_to_datetime(data):
    _3to2list = list(_parsedate_tz(data))
    dtuple, tz = [_3to2list[:-1]] + _3to2list[-1:]
    if tz is None:
        return datetime.datetime(*dtuple[:6])
    else:
        return datetime.datetime(tzinfo=datetime.timezone(datetime.timedelta(seconds=tz)), *dtuple[:6])


def parseaddr(addr):
    addrs = _AddressList(addr).addresslist
    if not addrs:
        return ('', '')
    return addrs[0]


def unquote(str):
    if len(str) > 1:
        if str.startswith(b'"') and str.endswith(b'"'):
            return str[1:-1].replace(b'\\\\', b'\\').replace(b'\\"', b'"')
        if str.startswith(b'<') and str.endswith(b'>'):
            return str[1:-1]
    return str


def decode_rfc2231(s):
    parts = s.split(TICK, 2)
    if len(parts) <= 2:
        return (None, None, s)
    else:
        return parts


def encode_rfc2231(s, charset=None, language=None):
    s = url_quote(s, safe=b'', encoding=charset or b'ascii')
    if charset is None and language is None:
        return s
    else:
        if language is None:
            language = b''
        return b"%s'%s'%s" % (charset, language, s)


rfc2231_continuation = re.compile(b'^(?P<name>\\w+)\\*((?P<num>[0-9]+)\\*?)?$', re.ASCII)

def decode_params(params):
    params = params[:]
    new_params = []
    rfc2231_params = {}
    name, value = params.pop(0)
    new_params.append((name, value))
    while params:
        name, value = params.pop(0)
        if name.endswith(b'*'):
            encoded = True
        else:
            encoded = False
        value = unquote(value)
        mo = rfc2231_continuation.match(name)
        if mo:
            name, num = mo.group(b'name', b'num')
            if num is not None:
                num = int(num)
            rfc2231_params.setdefault(name, []).append((num, value, encoded))
        else:
            new_params.append((name, b'"%s"' % quote(value)))

    if rfc2231_params:
        for name, continuations in rfc2231_params.items():
            value = []
            extended = False
            continuations.sort()
            for num, s, encoded in continuations:
                if encoded:
                    s = url_unquote(s, encoding=b'latin-1')
                    extended = True
                value.append(s)

            value = quote(EMPTYSTRING.join(value))
            if extended:
                charset, language, value = decode_rfc2231(value)
                new_params.append((name, (charset, language, b'"%s"' % value)))
            else:
                new_params.append((name, b'"%s"' % value))

    return new_params


def collapse_rfc2231_value(value, errors=b'replace', fallback_charset=b'us-ascii'):
    if not isinstance(value, tuple) or len(value) != 3:
        return unquote(value)
    charset, language, text = value
    rawbytes = bytes(text, b'raw-unicode-escape')
    try:
        return str(rawbytes, charset, errors)
    except LookupError:
        return unquote(text)


def localtime(dt=None, isdst=-1):
    if dt is None:
        return datetime.datetime.now(datetime.timezone.utc).astimezone()
    else:
        if dt.tzinfo is not None:
            return dt.astimezone()
        tm = dt.timetuple()[:-1] + (isdst,)
        seconds = time.mktime(tm)
        localtm = time.localtime(seconds)
        try:
            delta = datetime.timedelta(seconds=localtm.tm_gmtoff)
            tz = datetime.timezone(delta, localtm.tm_zone)
        except AttributeError:
            delta = dt - datetime.datetime(*time.gmtime(seconds)[:6])
            dst = time.daylight and localtm.tm_isdst > 0
            gmtoff = -(time.altzone if dst else time.timezone)
            if delta == datetime.timedelta(seconds=gmtoff):
                tz = datetime.timezone(delta, time.tzname[dst])
            else:
                tz = datetime.timezone(delta)

        return dt.replace(tzinfo=tz)