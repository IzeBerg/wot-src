from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
from future.builtins import super
import _socket
from _socket import *
import os, sys, io
try:
    import errno
except ImportError:
    errno = None

EBADF = getattr(errno, b'EBADF', 9)
EAGAIN = getattr(errno, b'EAGAIN', 11)
EWOULDBLOCK = getattr(errno, b'EWOULDBLOCK', 11)
__all__ = [
 b'getfqdn', b'create_connection']
__all__.extend(os._get_exports_list(_socket))
_realsocket = socket
if sys.platform.lower().startswith(b'win'):
    errorTab = {}
    errorTab[10004] = b'The operation was interrupted.'
    errorTab[10009] = b'A bad file handle was passed.'
    errorTab[10013] = b'Permission denied.'
    errorTab[10014] = b'A fault occurred on the network??'
    errorTab[10022] = b'An invalid operation was attempted.'
    errorTab[10035] = b'The socket operation would block'
    errorTab[10036] = b'A blocking operation is already in progress.'
    errorTab[10048] = b'The network address is in use.'
    errorTab[10054] = b'The connection has been reset.'
    errorTab[10058] = b'The network has been shut down.'
    errorTab[10060] = b'The operation timed out.'
    errorTab[10061] = b'Connection refused.'
    errorTab[10063] = b'The name is too long.'
    errorTab[10064] = b'The host is down.'
    errorTab[10065] = b'The host is unreachable.'
    __all__.append(b'errorTab')

class socket(_socket.socket):
    __slots__ = [
     b'__weakref__', b'_io_refs', b'_closed']

    def __init__(self, family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None):
        if fileno is None:
            _socket.socket.__init__(self, family, type, proto)
        else:
            _socket.socket.__init__(self, family, type, proto, fileno)
        self._io_refs = 0
        self._closed = False
        return

    def __enter__(self):
        return self

    def __exit__(self, *args):
        if not self._closed:
            self.close()

    def __repr__(self):
        s = _socket.socket.__repr__(self)
        if s.startswith(b'<socket object'):
            s = b'<%s.%s%s%s' % (self.__class__.__module__,
             self.__class__.__name__,
             getattr(self, b'_closed', False) and b' [closed] ' or b'',
             s[7:])
        return s

    def __getstate__(self):
        raise TypeError(b'Cannot serialize socket object')

    def dup(self):
        fd = dup(self.fileno())
        sock = self.__class__(self.family, self.type, self.proto, fileno=fd)
        sock.settimeout(self.gettimeout())
        return sock

    def accept(self):
        fd, addr = self._accept()
        sock = socket(self.family, self.type, self.proto, fileno=fd)
        if getdefaulttimeout() is None and self.gettimeout():
            sock.setblocking(True)
        return (
         sock, addr)

    def makefile(self, mode=b'r', buffering=None, **_3to2kwargs):
        if b'newline' in _3to2kwargs:
            newline = _3to2kwargs[b'newline']
            del _3to2kwargs[b'newline']
        else:
            newline = None
        if b'errors' in _3to2kwargs:
            errors = _3to2kwargs[b'errors']
            del _3to2kwargs[b'errors']
        else:
            errors = None
        if b'encoding' in _3to2kwargs:
            encoding = _3to2kwargs[b'encoding']
            del _3to2kwargs[b'encoding']
        else:
            encoding = None
        for c in mode:
            if c not in ('r', 'w', 'b'):
                raise ValueError(b'invalid mode %r (only r, w, b allowed)')

        writing = b'w' in mode
        reading = b'r' in mode or not writing
        binary = b'b' in mode
        rawmode = b''
        if reading:
            rawmode += b'r'
        if writing:
            rawmode += b'w'
        raw = SocketIO(self, rawmode)
        self._io_refs += 1
        if buffering is None:
            buffering = -1
        if buffering < 0:
            buffering = io.DEFAULT_BUFFER_SIZE
        if buffering == 0:
            if not binary:
                raise ValueError(b'unbuffered streams must be binary')
            return raw
        if reading and writing:
            buffer = io.BufferedRWPair(raw, raw, buffering)
        elif reading:
            buffer = io.BufferedReader(raw, buffering)
        else:
            buffer = io.BufferedWriter(raw, buffering)
        if binary:
            return buffer
        else:
            text = io.TextIOWrapper(buffer, encoding, errors, newline)
            text.mode = mode
            return text

    def _decref_socketios(self):
        if self._io_refs > 0:
            self._io_refs -= 1
        if self._closed:
            self.close()

    def _real_close(self, _ss=_socket.socket):
        _ss.close(self)

    def close(self):
        self._closed = True
        if self._io_refs <= 0:
            self._real_close()

    def detach(self):
        self._closed = True
        return super().detach()


def fromfd(fd, family, type, proto=0):
    nfd = dup(fd)
    return socket(family, type, proto, nfd)


if hasattr(_socket.socket, b'share'):

    def fromshare(info):
        return socket(0, 0, 0, info)


if hasattr(_socket, b'socketpair'):

    def socketpair(family=None, type=SOCK_STREAM, proto=0):
        if family is None:
            try:
                family = AF_UNIX
            except NameError:
                family = AF_INET

        a, b = _socket.socketpair(family, type, proto)
        a = socket(family, type, proto, a.detach())
        b = socket(family, type, proto, b.detach())
        return (a, b)


_blocking_errnos = set([EAGAIN, EWOULDBLOCK])

class SocketIO(io.RawIOBase):

    def __init__(self, sock, mode):
        if mode not in ('r', 'w', 'rw', 'rb', 'wb', 'rwb'):
            raise ValueError(b'invalid mode: %r' % mode)
        io.RawIOBase.__init__(self)
        self._sock = sock
        if b'b' not in mode:
            mode += b'b'
        self._mode = mode
        self._reading = b'r' in mode
        self._writing = b'w' in mode
        self._timeout_occurred = False

    def readinto(self, b):
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise IOError(b'cannot read from timed out object')
        while True:
            try:
                return self._sock.recv_into(b)
            except timeout:
                self._timeout_occurred = True
                raise
            except error as e:
                if e.args[0] in _blocking_errnos:
                    return
                raise

        return

    def write(self, b):
        self._checkClosed()
        self._checkWritable()
        try:
            return self._sock.send(b)
        except error as e:
            if e.args[0] in _blocking_errnos:
                return
            raise

        return

    def readable(self):
        if self.closed:
            raise ValueError(b'I/O operation on closed socket.')
        return self._reading

    def writable(self):
        if self.closed:
            raise ValueError(b'I/O operation on closed socket.')
        return self._writing

    def seekable(self):
        if self.closed:
            raise ValueError(b'I/O operation on closed socket.')
        return super().seekable()

    def fileno(self):
        self._checkClosed()
        return self._sock.fileno()

    @property
    def name(self):
        if not self.closed:
            return self.fileno()
        else:
            return -1

    @property
    def mode(self):
        return self._mode

    def close(self):
        if self.closed:
            return
        else:
            io.RawIOBase.close(self)
            self._sock._decref_socketios()
            self._sock = None
            return


def getfqdn(name=b''):
    name = name.strip()
    if not name or name == b'0.0.0.0':
        name = gethostname()
    try:
        hostname, aliases, ipaddrs = gethostbyaddr(name)
    except error:
        pass

    aliases.insert(0, hostname)
    for name in aliases:
        if b'.' in name:
            break
    else:
        name = hostname

    return name


from socket import _GLOBAL_DEFAULT_TIMEOUT

def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT, source_address=None):
    host, port = address
    err = None
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
        af, socktype, proto, canonname, sa = res
        sock = None
        try:
            sock = socket(af, socktype, proto)
            if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                sock.settimeout(timeout)
            if source_address:
                sock.bind(source_address)
            sock.connect(sa)
            return sock
        except error as _:
            err = _
            if sock is not None:
                sock.close()

    if err is not None:
        raise err
    else:
        raise error(b'getaddrinfo returns an empty list')
    return