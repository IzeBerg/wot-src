from __future__ import absolute_import, division, print_function, unicode_literals
from future.builtins import bytes, dict, int, range, str
import base64
base64.encodebytes = base64.encodestring
base64.decodebytes = base64.decodestring
import sys, time
from datetime import datetime
from future.backports.http import client as http_client
from future.backports.urllib import parse as urllib_parse
from future.utils import ensure_new_type
from xml.parsers import expat
import socket, errno
from io import BytesIO
try:
    import gzip
except ImportError:
    gzip = None

def escape(s):
    s = s.replace(b'&', b'&amp;')
    s = s.replace(b'<', b'&lt;')
    return s.replace(b'>', b'&gt;')


__version__ = sys.version[:3]
MAXINT = 2147483647
MININT = -2147483648
PARSE_ERROR = -32700
SERVER_ERROR = -32600
APPLICATION_ERROR = -32500
SYSTEM_ERROR = -32400
TRANSPORT_ERROR = -32300
NOT_WELLFORMED_ERROR = -32700
UNSUPPORTED_ENCODING = -32701
INVALID_ENCODING_CHAR = -32702
INVALID_XMLRPC = -32600
METHOD_NOT_FOUND = -32601
INVALID_METHOD_PARAMS = -32602
INTERNAL_ERROR = -32603

class Error(Exception):

    def __str__(self):
        return repr(self)


class ProtocolError(Error):

    def __init__(self, url, errcode, errmsg, headers):
        Error.__init__(self)
        self.url = url
        self.errcode = errcode
        self.errmsg = errmsg
        self.headers = headers

    def __repr__(self):
        return b'<ProtocolError for %s: %s %s>' % (
         self.url, self.errcode, self.errmsg)


class ResponseError(Error):
    pass


class Fault(Error):

    def __init__(self, faultCode, faultString, **extra):
        Error.__init__(self)
        self.faultCode = faultCode
        self.faultString = faultString

    def __repr__(self):
        return b'<Fault %s: %r>' % (ensure_new_type(self.faultCode),
         ensure_new_type(self.faultString))


boolean = Boolean = bool

def _iso8601_format(value):
    return b'%04d%02d%02dT%02d:%02d:%02d' % (
     value.year, value.month, value.day,
     value.hour, value.minute, value.second)


def _strftime(value):
    if isinstance(value, datetime):
        return _iso8601_format(value)
    if not isinstance(value, (tuple, time.struct_time)):
        if value == 0:
            value = time.time()
        value = time.localtime(value)
    return b'%04d%02d%02dT%02d:%02d:%02d' % value[:6]


class DateTime(object):

    def __init__(self, value=0):
        if isinstance(value, str):
            self.value = value
        else:
            self.value = _strftime(value)

    def make_comparable(self, other):
        if isinstance(other, DateTime):
            s = self.value
            o = other.value
        elif isinstance(other, datetime):
            s = self.value
            o = _iso8601_format(other)
        elif isinstance(other, str):
            s = self.value
            o = other
        elif hasattr(other, b'timetuple'):
            s = self.timetuple()
            o = other.timetuple()
        else:
            otype = hasattr(other, b'__class__') and other.__class__.__name__ or type(other)
            raise TypeError(b"Can't compare %s and %s" % (
             self.__class__.__name__, otype))
        return (
         s, o)

    def __lt__(self, other):
        s, o = self.make_comparable(other)
        return s < o

    def __le__(self, other):
        s, o = self.make_comparable(other)
        return s <= o

    def __gt__(self, other):
        s, o = self.make_comparable(other)
        return s > o

    def __ge__(self, other):
        s, o = self.make_comparable(other)
        return s >= o

    def __eq__(self, other):
        s, o = self.make_comparable(other)
        return s == o

    def __ne__(self, other):
        s, o = self.make_comparable(other)
        return s != o

    def timetuple(self):
        return time.strptime(self.value, b'%Y%m%dT%H:%M:%S')

    def __str__(self):
        return self.value

    def __repr__(self):
        return b'<DateTime %r at %x>' % (ensure_new_type(self.value), id(self))

    def decode(self, data):
        self.value = str(data).strip()

    def encode(self, out):
        out.write(b'<value><dateTime.iso8601>')
        out.write(self.value)
        out.write(b'</dateTime.iso8601></value>\n')


def _datetime(data):
    value = DateTime()
    value.decode(data)
    return value


def _datetime_type(data):
    return datetime.strptime(data, b'%Y%m%dT%H:%M:%S')


class Binary(object):

    def __init__(self, data=None):
        if data is None:
            data = b''
        else:
            if not isinstance(data, (bytes, bytearray)):
                raise TypeError(b'expected bytes or bytearray, not %s' % data.__class__.__name__)
            data = bytes(data)
        self.data = data
        return

    def __str__(self):
        return str(self.data, b'latin-1')

    def __eq__(self, other):
        if isinstance(other, Binary):
            other = other.data
        return self.data == other

    def __ne__(self, other):
        if isinstance(other, Binary):
            other = other.data
        return self.data != other

    def decode(self, data):
        self.data = base64.decodebytes(data)

    def encode(self, out):
        out.write(b'<value><base64>\n')
        encoded = base64.encodebytes(self.data)
        out.write(encoded.decode(b'ascii'))
        out.write(b'</base64></value>\n')


def _binary(data):
    value = Binary()
    value.decode(data)
    return value


WRAPPERS = (
 DateTime, Binary)

class ExpatParser(object):

    def __init__(self, target):
        self._parser = parser = expat.ParserCreate(None, None)
        self._target = target
        parser.StartElementHandler = target.start
        parser.EndElementHandler = target.end
        parser.CharacterDataHandler = target.data
        encoding = None
        target.xml(encoding, None)
        return

    def feed(self, data):
        self._parser.Parse(data, 0)

    def close(self):
        self._parser.Parse(b'', 1)
        del self._target
        del self._parser


class Marshaller(object):

    def __init__(self, encoding=None, allow_none=False):
        self.memo = {}
        self.data = None
        self.encoding = encoding
        self.allow_none = allow_none
        return

    dispatch = {}

    def dumps(self, values):
        out = []
        write = out.append
        dump = self.__dump
        if isinstance(values, Fault):
            write(b'<fault>\n')
            dump({b'faultCode': values.faultCode, b'faultString': values.faultString}, write)
            write(b'</fault>\n')
        else:
            write(b'<params>\n')
            for v in values:
                write(b'<param>\n')
                dump(v, write)
                write(b'</param>\n')

            write(b'</params>\n')
        result = (b'').join(out)
        return str(result)

    def __dump(self, value, write):
        try:
            f = self.dispatch[type(ensure_new_type(value))]
        except KeyError:
            if not hasattr(value, b'__dict__'):
                raise TypeError(b'cannot marshal %s objects' % type(value))
            for type_ in type(value).__mro__:
                if type_ in self.dispatch.keys():
                    raise TypeError(b'cannot marshal %s objects' % type(value))

            f = self.dispatch[b'_arbitrary_instance']

        f(self, value, write)

    def dump_nil(self, value, write):
        if not self.allow_none:
            raise TypeError(b'cannot marshal None unless allow_none is enabled')
        write(b'<value><nil/></value>')

    dispatch[type(None)] = dump_nil

    def dump_bool(self, value, write):
        write(b'<value><boolean>')
        write(value and b'1' or b'0')
        write(b'</boolean></value>\n')

    dispatch[bool] = dump_bool

    def dump_long(self, value, write):
        if value > MAXINT or value < MININT:
            raise OverflowError(b'long int exceeds XML-RPC limits')
        write(b'<value><int>')
        write(str(int(value)))
        write(b'</int></value>\n')

    dispatch[int] = dump_long
    dump_int = dump_long

    def dump_double(self, value, write):
        write(b'<value><double>')
        write(repr(ensure_new_type(value)))
        write(b'</double></value>\n')

    dispatch[float] = dump_double

    def dump_unicode(self, value, write, escape=escape):
        write(b'<value><string>')
        write(escape(value))
        write(b'</string></value>\n')

    dispatch[str] = dump_unicode

    def dump_bytes(self, value, write):
        write(b'<value><base64>\n')
        encoded = base64.encodebytes(value)
        write(encoded.decode(b'ascii'))
        write(b'</base64></value>\n')

    dispatch[bytes] = dump_bytes
    dispatch[bytearray] = dump_bytes

    def dump_array(self, value, write):
        i = id(value)
        if i in self.memo:
            raise TypeError(b'cannot marshal recursive sequences')
        self.memo[i] = None
        dump = self.__dump
        write(b'<value><array><data>\n')
        for v in value:
            dump(v, write)

        write(b'</data></array></value>\n')
        del self.memo[i]
        return

    dispatch[tuple] = dump_array
    dispatch[list] = dump_array

    def dump_struct(self, value, write, escape=escape):
        i = id(value)
        if i in self.memo:
            raise TypeError(b'cannot marshal recursive dictionaries')
        self.memo[i] = None
        dump = self.__dump
        write(b'<value><struct>\n')
        for k, v in value.items():
            write(b'<member>\n')
            if not isinstance(k, str):
                raise TypeError(b'dictionary key must be string')
            write(b'<name>%s</name>\n' % escape(k))
            dump(v, write)
            write(b'</member>\n')

        write(b'</struct></value>\n')
        del self.memo[i]
        return

    dispatch[dict] = dump_struct

    def dump_datetime(self, value, write):
        write(b'<value><dateTime.iso8601>')
        write(_strftime(value))
        write(b'</dateTime.iso8601></value>\n')

    dispatch[datetime] = dump_datetime

    def dump_instance(self, value, write):
        if value.__class__ in WRAPPERS:
            self.write = write
            value.encode(self)
            del self.write
        else:
            self.dump_struct(value.__dict__, write)

    dispatch[DateTime] = dump_instance
    dispatch[Binary] = dump_instance
    dispatch[b'_arbitrary_instance'] = dump_instance


class Unmarshaller(object):

    def __init__(self, use_datetime=False, use_builtin_types=False):
        self._type = None
        self._stack = []
        self._marks = []
        self._data = []
        self._methodname = None
        self._encoding = b'utf-8'
        self.append = self._stack.append
        self._use_datetime = use_builtin_types or use_datetime
        self._use_bytes = use_builtin_types
        return

    def close(self):
        if self._type is None or self._marks:
            raise ResponseError()
        if self._type == b'fault':
            raise Fault(**self._stack[0])
        return tuple(self._stack)

    def getmethodname(self):
        return self._methodname

    def xml(self, encoding, standalone):
        self._encoding = encoding

    def start(self, tag, attrs):
        if tag == b'array' or tag == b'struct':
            self._marks.append(len(self._stack))
        self._data = []
        self._value = tag == b'value'

    def data(self, text):
        self._data.append(text)

    def end(self, tag):
        try:
            f = self.dispatch[tag]
        except KeyError:
            pass
        else:
            return f(self, (b'').join(self._data))

    def end_dispatch(self, tag, data):
        try:
            f = self.dispatch[tag]
        except KeyError:
            pass
        else:
            return f(self, data)

    dispatch = {}

    def end_nil(self, data):
        self.append(None)
        self._value = 0
        return

    dispatch[b'nil'] = end_nil

    def end_boolean(self, data):
        if data == b'0':
            self.append(False)
        elif data == b'1':
            self.append(True)
        else:
            raise TypeError(b'bad boolean value')
        self._value = 0

    dispatch[b'boolean'] = end_boolean

    def end_int(self, data):
        self.append(int(data))
        self._value = 0

    dispatch[b'i4'] = end_int
    dispatch[b'i8'] = end_int
    dispatch[b'int'] = end_int

    def end_double(self, data):
        self.append(float(data))
        self._value = 0

    dispatch[b'double'] = end_double

    def end_string(self, data):
        if self._encoding:
            data = data.decode(self._encoding)
        self.append(data)
        self._value = 0

    dispatch[b'string'] = end_string
    dispatch[b'name'] = end_string

    def end_array(self, data):
        mark = self._marks.pop()
        self._stack[mark:] = [
         self._stack[mark:]]
        self._value = 0

    dispatch[b'array'] = end_array

    def end_struct(self, data):
        mark = self._marks.pop()
        dict = {}
        items = self._stack[mark:]
        for i in range(0, len(items), 2):
            dict[items[i]] = items[(i + 1)]

        self._stack[mark:] = [
         dict]
        self._value = 0

    dispatch[b'struct'] = end_struct

    def end_base64(self, data):
        value = Binary()
        value.decode(data.encode(b'ascii'))
        if self._use_bytes:
            value = value.data
        self.append(value)
        self._value = 0

    dispatch[b'base64'] = end_base64

    def end_dateTime(self, data):
        value = DateTime()
        value.decode(data)
        if self._use_datetime:
            value = _datetime_type(data)
        self.append(value)

    dispatch[b'dateTime.iso8601'] = end_dateTime

    def end_value(self, data):
        if self._value:
            self.end_string(data)

    dispatch[b'value'] = end_value

    def end_params(self, data):
        self._type = b'params'

    dispatch[b'params'] = end_params

    def end_fault(self, data):
        self._type = b'fault'

    dispatch[b'fault'] = end_fault

    def end_methodName(self, data):
        if self._encoding:
            data = data.decode(self._encoding)
        self._methodname = data
        self._type = b'methodName'

    dispatch[b'methodName'] = end_methodName


class _MultiCallMethod(object):

    def __init__(self, call_list, name):
        self.__call_list = call_list
        self.__name = name

    def __getattr__(self, name):
        return _MultiCallMethod(self.__call_list, b'%s.%s' % (self.__name, name))

    def __call__(self, *args):
        self.__call_list.append((self.__name, args))


class MultiCallIterator(object):

    def __init__(self, results):
        self.results = results

    def __getitem__(self, i):
        item = self.results[i]
        if isinstance(type(item), dict):
            raise Fault(item[b'faultCode'], item[b'faultString'])
        else:
            if type(item) == type([]):
                return item[0]
            raise ValueError(b'unexpected type in multicall result')


class MultiCall(object):

    def __init__(self, server):
        self.__server = server
        self.__call_list = []

    def __repr__(self):
        return b'<MultiCall at %x>' % id(self)

    __str__ = __repr__

    def __getattr__(self, name):
        return _MultiCallMethod(self.__call_list, name)

    def __call__(self):
        marshalled_list = []
        for name, args in self.__call_list:
            marshalled_list.append({b'methodName': name, b'params': args})

        return MultiCallIterator(self.__server.system.multicall(marshalled_list))


FastMarshaller = FastParser = FastUnmarshaller = None

def getparser(use_datetime=False, use_builtin_types=False):
    if FastParser and FastUnmarshaller:
        if use_builtin_types:
            mkdatetime = _datetime_type
            mkbytes = base64.decodebytes
        elif use_datetime:
            mkdatetime = _datetime_type
            mkbytes = _binary
        else:
            mkdatetime = _datetime
            mkbytes = _binary
        target = FastUnmarshaller(True, False, mkbytes, mkdatetime, Fault)
        parser = FastParser(target)
    else:
        target = Unmarshaller(use_datetime=use_datetime, use_builtin_types=use_builtin_types)
        if FastParser:
            parser = FastParser(target)
        else:
            parser = ExpatParser(target)
    return (
     parser, target)


def dumps(params, methodname=None, methodresponse=None, encoding=None, allow_none=False):
    if isinstance(params, Fault):
        methodresponse = 1
    elif methodresponse and isinstance(params, tuple):
        pass
    if not encoding:
        encoding = b'utf-8'
    if FastMarshaller:
        m = FastMarshaller(encoding)
    else:
        m = Marshaller(encoding, allow_none)
    data = m.dumps(params)
    if encoding != b'utf-8':
        xmlheader = b"<?xml version='1.0' encoding='%s'?>\n" % str(encoding)
    else:
        xmlheader = b"<?xml version='1.0'?>\n"
    if methodname:
        if not isinstance(methodname, str):
            methodname = methodname.encode(encoding)
        data = (xmlheader,
         b'<methodCall>\n<methodName>',
         methodname, b'</methodName>\n',
         data,
         b'</methodCall>\n')
    elif methodresponse:
        data = (
         xmlheader,
         b'<methodResponse>\n',
         data,
         b'</methodResponse>\n')
    else:
        return data
    return str(b'').join(data)


def loads(data, use_datetime=False, use_builtin_types=False):
    p, u = getparser(use_datetime=use_datetime, use_builtin_types=use_builtin_types)
    p.feed(data)
    p.close()
    return (u.close(), u.getmethodname())


def gzip_encode(data):
    if not gzip:
        raise NotImplementedError
    f = BytesIO()
    gzf = gzip.GzipFile(mode=b'wb', fileobj=f, compresslevel=1)
    gzf.write(data)
    gzf.close()
    encoded = f.getvalue()
    f.close()
    return encoded


def gzip_decode(data):
    if not gzip:
        raise NotImplementedError
    f = BytesIO(data)
    gzf = gzip.GzipFile(mode=b'rb', fileobj=f)
    try:
        decoded = gzf.read()
    except IOError:
        raise ValueError(b'invalid data')

    f.close()
    gzf.close()
    return decoded


class GzipDecodedResponse(gzip.GzipFile if gzip else object):

    def __init__(self, response):
        if not gzip:
            raise NotImplementedError
        self.io = BytesIO(response.read())
        gzip.GzipFile.__init__(self, mode=b'rb', fileobj=self.io)

    def close(self):
        gzip.GzipFile.close(self)
        self.io.close()


class _Method(object):

    def __init__(self, send, name):
        self.__send = send
        self.__name = name

    def __getattr__(self, name):
        return _Method(self.__send, b'%s.%s' % (self.__name, name))

    def __call__(self, *args):
        return self.__send(self.__name, args)


class Transport(object):
    user_agent = b'Python-xmlrpc/%s' % __version__
    accept_gzip_encoding = True
    encode_threshold = None

    def __init__(self, use_datetime=False, use_builtin_types=False):
        self._use_datetime = use_datetime
        self._use_builtin_types = use_builtin_types
        self._connection = (None, None)
        self._extra_headers = []
        return

    def request(self, host, handler, request_body, verbose=False):
        for i in (0, 1):
            try:
                return self.single_request(host, handler, request_body, verbose)
            except socket.error as e:
                if i or e.errno not in (errno.ECONNRESET, errno.ECONNABORTED, errno.EPIPE):
                    raise
            except http_client.BadStatusLine:
                if i:
                    raise

    def single_request(self, host, handler, request_body, verbose=False):
        try:
            http_conn = self.send_request(host, handler, request_body, verbose)
            resp = http_conn.getresponse()
            if resp.status == 200:
                self.verbose = verbose
                return self.parse_response(resp)
        except Fault:
            raise
        except Exception:
            self.close()
            raise

        if resp.getheader(b'content-length', b''):
            resp.read()
        raise ProtocolError(host + handler, resp.status, resp.reason, dict(resp.getheaders()))

    def getparser(self):
        return getparser(use_datetime=self._use_datetime, use_builtin_types=self._use_builtin_types)

    def get_host_info(self, host):
        x509 = {}
        if isinstance(host, tuple):
            host, x509 = host
        auth, host = urllib_parse.splituser(host)
        if auth:
            auth = urllib_parse.unquote_to_bytes(auth)
            auth = base64.encodebytes(auth).decode(b'utf-8')
            auth = (b'').join(auth.split())
            extra_headers = [
             (
              b'Authorization', b'Basic ' + auth)]
        else:
            extra_headers = []
        return (
         host, extra_headers, x509)

    def make_connection(self, host):
        if self._connection and host == self._connection[0]:
            return self._connection[1]
        chost, self._extra_headers, x509 = self.get_host_info(host)
        self._connection = (host, http_client.HTTPConnection(chost))
        return self._connection[1]

    def close(self):
        if self._connection[1]:
            self._connection[1].close()
            self._connection = (None, None)
        return

    def send_request(self, host, handler, request_body, debug):
        connection = self.make_connection(host)
        headers = self._extra_headers[:]
        if debug:
            connection.set_debuglevel(1)
        if self.accept_gzip_encoding and gzip:
            connection.putrequest(b'POST', handler, skip_accept_encoding=True)
            headers.append(('Accept-Encoding', 'gzip'))
        else:
            connection.putrequest(b'POST', handler)
        headers.append(('Content-Type', 'text/xml'))
        headers.append((b'User-Agent', self.user_agent))
        self.send_headers(connection, headers)
        self.send_content(connection, request_body)
        return connection

    def send_headers(self, connection, headers):
        for key, val in headers:
            connection.putheader(key, val)

    def send_content(self, connection, request_body):
        if self.encode_threshold is not None and self.encode_threshold < len(request_body) and gzip:
            connection.putheader(b'Content-Encoding', b'gzip')
            request_body = gzip_encode(request_body)
        connection.putheader(b'Content-Length', str(len(request_body)))
        connection.endheaders(request_body)
        return

    def parse_response(self, response):
        if hasattr(response, b'getheader'):
            if response.getheader(b'Content-Encoding', b'') == b'gzip':
                stream = GzipDecodedResponse(response)
            else:
                stream = response
        else:
            stream = response
        p, u = self.getparser()
        while 1:
            data = stream.read(1024)
            if not data:
                break
            if self.verbose:
                print(b'body:', repr(data))
            p.feed(data)

        if stream is not response:
            stream.close()
        p.close()
        return u.close()


class SafeTransport(Transport):

    def make_connection(self, host):
        if self._connection and host == self._connection[0]:
            return self._connection[1]
        else:
            if not hasattr(http_client, b'HTTPSConnection'):
                raise NotImplementedError(b"your version of http.client doesn't support HTTPS")
            chost, self._extra_headers, x509 = self.get_host_info(host)
            self._connection = (host,
             http_client.HTTPSConnection(chost, None, **(x509 or {})))
            return self._connection[1]


class ServerProxy(object):

    def __init__(self, uri, transport=None, encoding=None, verbose=False, allow_none=False, use_datetime=False, use_builtin_types=False):
        type, uri = urllib_parse.splittype(uri)
        if type not in ('http', 'https'):
            raise IOError(b'unsupported XML-RPC protocol')
        self.__host, self.__handler = urllib_parse.splithost(uri)
        if not self.__handler:
            self.__handler = b'/RPC2'
        if transport is None:
            if type == b'https':
                handler = SafeTransport
            else:
                handler = Transport
            transport = handler(use_datetime=use_datetime, use_builtin_types=use_builtin_types)
        self.__transport = transport
        self.__encoding = encoding or b'utf-8'
        self.__verbose = verbose
        self.__allow_none = allow_none
        return

    def __close(self):
        self.__transport.close()

    def __request(self, methodname, params):
        request = dumps(params, methodname, encoding=self.__encoding, allow_none=self.__allow_none).encode(self.__encoding)
        response = self.__transport.request(self.__host, self.__handler, request, verbose=self.__verbose)
        if len(response) == 1:
            response = response[0]
        return response

    def __repr__(self):
        return b'<ServerProxy for %s%s>' % (
         self.__host, self.__handler)

    __str__ = __repr__

    def __getattr__(self, name):
        return _Method(self.__request, name)

    def __call__(self, attr):
        if attr == b'close':
            return self.__close
        if attr == b'transport':
            return self.__transport
        raise AttributeError(b'Attribute %r not found' % (attr,))


Server = ServerProxy
if __name__ == b'__main__':
    server = ServerProxy(b'http://localhost:8000')
    try:
        print(server.currentTime.getCurrentTime())
    except Error as v:
        print(b'ERROR', v)

    multi = MultiCall(server)
    multi.getData()
    multi.pow(2, 9)
    multi.add(1, 2)
    try:
        for response in multi():
            print(response)

    except Error as v:
        print(b'ERROR', v)