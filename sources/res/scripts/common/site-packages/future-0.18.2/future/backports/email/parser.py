from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
__all__ = [
 b'Parser', b'HeaderParser', b'BytesParser', b'BytesHeaderParser']
import warnings
from io import StringIO, TextIOWrapper
from future.backports.email.feedparser import FeedParser, BytesFeedParser
from future.backports.email.message import Message
from future.backports.email._policybase import compat32

class Parser(object):

    def __init__(self, _class=Message, **_3to2kwargs):
        if b'policy' in _3to2kwargs:
            policy = _3to2kwargs[b'policy']
            del _3to2kwargs[b'policy']
        else:
            policy = compat32
        self._class = _class
        self.policy = policy

    def parse(self, fp, headersonly=False):
        feedparser = FeedParser(self._class, policy=self.policy)
        if headersonly:
            feedparser._set_headersonly()
        while True:
            data = fp.read(8192)
            if not data:
                break
            feedparser.feed(data)

        return feedparser.close()

    def parsestr(self, text, headersonly=False):
        return self.parse(StringIO(text), headersonly=headersonly)


class HeaderParser(Parser):

    def parse(self, fp, headersonly=True):
        return Parser.parse(self, fp, True)

    def parsestr(self, text, headersonly=True):
        return Parser.parsestr(self, text, True)


class BytesParser(object):

    def __init__(self, *args, **kw):
        self.parser = Parser(*args, **kw)

    def parse(self, fp, headersonly=False):
        fp = TextIOWrapper(fp, encoding=b'ascii', errors=b'surrogateescape')
        with fp:
            return self.parser.parse(fp, headersonly)

    def parsebytes(self, text, headersonly=False):
        text = text.decode(b'ASCII', errors=b'surrogateescape')
        return self.parser.parsestr(text, headersonly)


class BytesHeaderParser(BytesParser):

    def parse(self, fp, headersonly=True):
        return BytesParser.parse(self, fp, headersonly=True)

    def parsebytes(self, text, headersonly=True):
        return BytesParser.parsebytes(self, text, headersonly=True)