from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
from future.builtins import chr, dict, int, str
from future.utils import PY2, as_native_str
import re
if PY2:
    re.ASCII = 0
import string
__all__ = [b'CookieError', b'BaseCookie', b'SimpleCookie']
_nulljoin = (b'').join
_semispacejoin = (b'; ').join
_spacejoin = (b' ').join

class CookieError(Exception):
    pass


_LegalChars = string.ascii_letters + string.digits + b"!#$%&'*+-.^_`|~:"
_Translator = {b'\x00': b'\\000', 
   b'\x01': b'\\001', b'\x02': b'\\002', b'\x03': b'\\003', 
   b'\x04': b'\\004', b'\x05': b'\\005', b'\x06': b'\\006', 
   b'\x07': b'\\007', b'\x08': b'\\010', b'\t': b'\\011', 
   b'\n': b'\\012', b'\x0b': b'\\013', b'\x0c': b'\\014', 
   b'\r': b'\\015', b'\x0e': b'\\016', b'\x0f': b'\\017', 
   b'\x10': b'\\020', b'\x11': b'\\021', b'\x12': b'\\022', 
   b'\x13': b'\\023', b'\x14': b'\\024', b'\x15': b'\\025', 
   b'\x16': b'\\026', b'\x17': b'\\027', b'\x18': b'\\030', 
   b'\x19': b'\\031', b'\x1a': b'\\032', b'\x1b': b'\\033', 
   b'\x1c': b'\\034', b'\x1d': b'\\035', b'\x1e': b'\\036', 
   b'\x1f': b'\\037', b',': b'\\054', 
   b';': b'\\073', b'"': b'\\"', 
   b'\\': b'\\\\', b'\x7f': b'\\177', 
   b'\x80': b'\\200', b'\x81': b'\\201', b'\x82': b'\\202', 
   b'\x83': b'\\203', b'\x84': b'\\204', b'\x85': b'\\205', 
   b'\x86': b'\\206', b'\x87': b'\\207', b'\x88': b'\\210', 
   b'\x89': b'\\211', b'\x8a': b'\\212', b'\x8b': b'\\213', 
   b'\x8c': b'\\214', b'\x8d': b'\\215', b'\x8e': b'\\216', 
   b'\x8f': b'\\217', b'\x90': b'\\220', b'\x91': b'\\221', 
   b'\x92': b'\\222', b'\x93': b'\\223', b'\x94': b'\\224', 
   b'\x95': b'\\225', b'\x96': b'\\226', b'\x97': b'\\227', 
   b'\x98': b'\\230', b'\x99': b'\\231', b'\x9a': b'\\232', 
   b'\x9b': b'\\233', b'\x9c': b'\\234', b'\x9d': b'\\235', 
   b'\x9e': b'\\236', b'\x9f': b'\\237', b'\xa0': b'\\240', 
   b'¡': b'\\241', b'¢': b'\\242', b'£': b'\\243', 
   b'¤': b'\\244', b'¥': b'\\245', b'¦': b'\\246', 
   b'§': b'\\247', b'¨': b'\\250', b'©': b'\\251', 
   b'ª': b'\\252', b'«': b'\\253', b'¬': b'\\254', 
   b'\xad': b'\\255', b'®': b'\\256', b'¯': b'\\257', 
   b'°': b'\\260', b'±': b'\\261', b'²': b'\\262', 
   b'³': b'\\263', b'´': b'\\264', b'µ': b'\\265', 
   b'¶': b'\\266', b'·': b'\\267', b'¸': b'\\270', 
   b'¹': b'\\271', b'º': b'\\272', b'»': b'\\273', 
   b'¼': b'\\274', b'½': b'\\275', b'¾': b'\\276', 
   b'¿': b'\\277', b'À': b'\\300', b'Á': b'\\301', 
   b'Â': b'\\302', b'Ã': b'\\303', b'Ä': b'\\304', 
   b'Å': b'\\305', b'Æ': b'\\306', b'Ç': b'\\307', 
   b'È': b'\\310', b'É': b'\\311', b'Ê': b'\\312', 
   b'Ë': b'\\313', b'Ì': b'\\314', b'Í': b'\\315', 
   b'Î': b'\\316', b'Ï': b'\\317', b'Ð': b'\\320', 
   b'Ñ': b'\\321', b'Ò': b'\\322', b'Ó': b'\\323', 
   b'Ô': b'\\324', b'Õ': b'\\325', b'Ö': b'\\326', 
   b'×': b'\\327', b'Ø': b'\\330', b'Ù': b'\\331', 
   b'Ú': b'\\332', b'Û': b'\\333', b'Ü': b'\\334', 
   b'Ý': b'\\335', b'Þ': b'\\336', b'ß': b'\\337', 
   b'à': b'\\340', b'á': b'\\341', b'â': b'\\342', 
   b'ã': b'\\343', b'ä': b'\\344', b'å': b'\\345', 
   b'æ': b'\\346', b'ç': b'\\347', b'è': b'\\350', 
   b'é': b'\\351', b'ê': b'\\352', b'ë': b'\\353', 
   b'ì': b'\\354', b'í': b'\\355', b'î': b'\\356', 
   b'ï': b'\\357', b'ð': b'\\360', b'ñ': b'\\361', 
   b'ò': b'\\362', b'ó': b'\\363', b'ô': b'\\364', 
   b'õ': b'\\365', b'ö': b'\\366', b'÷': b'\\367', 
   b'ø': b'\\370', b'ù': b'\\371', b'ú': b'\\372', 
   b'û': b'\\373', b'ü': b'\\374', b'ý': b'\\375', 
   b'þ': b'\\376', b'ÿ': b'\\377'}

def _quote(str, LegalChars=_LegalChars):
    if all(c in LegalChars for c in str):
        return str
    else:
        return b'"' + _nulljoin(_Translator.get(s, s) for s in str) + b'"'


_OctalPatt = re.compile(b'\\\\[0-3][0-7][0-7]')
_QuotePatt = re.compile(b'[\\\\].')

def _unquote(mystr):
    if len(mystr) < 2:
        return mystr
    if mystr[0] != b'"' or mystr[(-1)] != b'"':
        return mystr
    mystr = mystr[1:-1]
    i = 0
    n = len(mystr)
    res = []
    while 0 <= i < n:
        o_match = _OctalPatt.search(mystr, i)
        q_match = _QuotePatt.search(mystr, i)
        if not o_match and not q_match:
            res.append(mystr[i:])
            break
        j = k = -1
        if o_match:
            j = o_match.start(0)
        if q_match:
            k = q_match.start(0)
        if q_match and (not o_match or k < j):
            res.append(mystr[i:k])
            res.append(mystr[(k + 1)])
            i = k + 2
        else:
            res.append(mystr[i:j])
            res.append(chr(int(mystr[j + 1:j + 4], 8)))
            i = j + 4

    return _nulljoin(res)


_weekdayname = [
 b'Mon', b'Tue', b'Wed', b'Thu', b'Fri', b'Sat', b'Sun']
_monthname = [
 None,
 b'Jan', b'Feb', b'Mar', b'Apr', b'May', b'Jun',
 b'Jul', b'Aug', b'Sep', b'Oct', b'Nov', b'Dec']

def _getdate(future=0, weekdayname=_weekdayname, monthname=_monthname):
    from time import gmtime, time
    now = time()
    year, month, day, hh, mm, ss, wd, y, z = gmtime(now + future)
    return b'%s, %02d %3s %4d %02d:%02d:%02d GMT' % (
     weekdayname[wd], day, monthname[month], year, hh, mm, ss)


class Morsel(dict):
    _reserved = {b'expires': b'expires', 
       b'path': b'Path', 
       b'comment': b'Comment', 
       b'domain': b'Domain', 
       b'max-age': b'Max-Age', 
       b'secure': b'secure', 
       b'httponly': b'httponly', 
       b'version': b'Version'}
    _flags = set([b'secure', b'httponly'])

    def __init__(self):
        self.key = self.value = self.coded_value = None
        for key in self._reserved:
            dict.__setitem__(self, key, b'')

        return

    def __setitem__(self, K, V):
        K = K.lower()
        if K not in self._reserved:
            raise CookieError(b'Invalid Attribute %s' % K)
        dict.__setitem__(self, K, V)

    def isReservedKey(self, K):
        return K.lower() in self._reserved

    def set(self, key, val, coded_val, LegalChars=_LegalChars):
        if key.lower() in self._reserved:
            raise CookieError(b'Attempt to set a reserved key: %s' % key)
        if any(c not in LegalChars for c in key):
            raise CookieError(b'Illegal key value: %s' % key)
        self.key = key
        self.value = val
        self.coded_value = coded_val

    def output(self, attrs=None, header=b'Set-Cookie:'):
        return b'%s %s' % (header, self.OutputString(attrs))

    __str__ = output

    @as_native_str()
    def __repr__(self):
        if PY2 and isinstance(self.value, unicode):
            val = str(self.value)
        else:
            val = self.value
        return b'<%s: %s=%s>' % (self.__class__.__name__,
         str(self.key), repr(val))

    def js_output(self, attrs=None):
        return b'\n        <script type="text/javascript">\n        <!-- begin hiding\n        document.cookie = "%s";\n        // end hiding -->\n        </script>\n        ' % self.OutputString(attrs).replace(b'"', b'\\"')

    def OutputString(self, attrs=None):
        result = []
        append = result.append
        append(b'%s=%s' % (self.key, self.coded_value))
        if attrs is None:
            attrs = self._reserved
        items = sorted(self.items())
        for key, value in items:
            if value == b'':
                continue
            if key not in attrs:
                continue
            if key == b'expires' and isinstance(value, int):
                append(b'%s=%s' % (self._reserved[key], _getdate(value)))
            elif key == b'max-age' and isinstance(value, int):
                append(b'%s=%d' % (self._reserved[key], value))
            elif key == b'secure':
                append(str(self._reserved[key]))
            elif key == b'httponly':
                append(str(self._reserved[key]))
            else:
                append(b'%s=%s' % (self._reserved[key], value))

        return _semispacejoin(result)


_LegalCharsPatt = b"[\\w\\d!#%&'~_`><@,:/\\$\\*\\+\\-\\.\\^\\|\\)\\(\\?\\}\\{\\=]"
_CookiePattern = re.compile(b"\n    (?x)                           # This is a verbose pattern\n    (?P<key>                       # Start of group 'key'\n    " + _LegalCharsPatt + b'+?   # Any word of at least one letter\n    )                              # End of group \'key\'\n    (                              # Optional group: there may not be a value.\n    \\s*=\\s*                          # Equal Sign\n    (?P<val>                         # Start of group \'val\'\n    "(?:[^\\\\"]|\\\\.)*"                  # Any doublequoted string\n    |                                  # or\n    \\w{3},\\s[\\w\\d\\s-]{9,11}\\s[\\d:]{8}\\sGMT  # Special case for "expires" attr\n    |                                  # or\n    ' + _LegalCharsPatt + b"*      # Any word or empty string\n    )                                # End of group 'val'\n    )?                             # End of optional value group\n    \\s*                            # Any number of spaces.\n    (\\s+|;|$)                      # Ending either at space, semicolon, or EOS.\n    ", re.ASCII)

class BaseCookie(dict):

    def value_decode(self, val):
        return (
         val, val)

    def value_encode(self, val):
        strval = str(val)
        return (strval, strval)

    def __init__(self, input=None):
        if input:
            self.load(input)

    def __set(self, key, real_value, coded_value):
        M = self.get(key, Morsel())
        M.set(key, real_value, coded_value)
        dict.__setitem__(self, key, M)

    def __setitem__(self, key, value):
        rval, cval = self.value_encode(value)
        self.__set(key, rval, cval)

    def output(self, attrs=None, header=b'Set-Cookie:', sep=b'\r\n'):
        result = []
        items = sorted(self.items())
        for key, value in items:
            result.append(value.output(attrs, header))

        return sep.join(result)

    __str__ = output

    @as_native_str()
    def __repr__(self):
        l = []
        items = sorted(self.items())
        for key, value in items:
            if PY2 and isinstance(value.value, unicode):
                val = str(value.value)
            else:
                val = value.value
            l.append(b'%s=%s' % (str(key), repr(val)))

        return b'<%s: %s>' % (self.__class__.__name__, _spacejoin(l))

    def js_output(self, attrs=None):
        result = []
        items = sorted(self.items())
        for key, value in items:
            result.append(value.js_output(attrs))

        return _nulljoin(result)

    def load(self, rawdata):
        if isinstance(rawdata, str):
            self.__parse_string(rawdata)
        else:
            for key, value in rawdata.items():
                self[key] = value

    def __parse_string(self, mystr, patt=_CookiePattern):
        i = 0
        n = len(mystr)
        M = None
        while 0 <= i < n:
            match = patt.search(mystr, i)
            if not match:
                break
            key, value = match.group(b'key'), match.group(b'val')
            i = match.end(0)
            if key[0] == b'$':
                if M:
                    M[key[1:]] = value
            elif key.lower() in Morsel._reserved:
                if M:
                    if value is None:
                        if key.lower() in Morsel._flags:
                            M[key] = True
                    else:
                        M[key] = _unquote(value)
            elif value is not None:
                rval, cval = self.value_decode(value)
                self.__set(key, rval, cval)
                M = self[key]

        return


class SimpleCookie(BaseCookie):

    def value_decode(self, val):
        return (
         _unquote(val), val)

    def value_encode(self, val):
        strval = str(val)
        return (strval, _quote(strval))