from __future__ import absolute_import, division, unicode_literals
from future.builtins import list, range, str, zip
__all__ = [
 b'Message']
import re, uu, base64, binascii
from io import BytesIO, StringIO
from future.utils import as_native_str
from future.backports.email import utils
from future.backports.email import errors
from future.backports.email._policybase import compat32
from future.backports.email import charset as _charset
from future.backports.email._encoded_words import decode_b
Charset = _charset.Charset
SEMISPACE = b'; '
tspecials = re.compile(b'[ \\(\\)<>@,;:\\\\"/\\[\\]\\?=]')

def _splitparam(param):
    a, sep, b = str(param).partition(b';')
    if not sep:
        return (a.strip(), None)
    else:
        return (
         a.strip(), b.strip())


def _formatparam(param, value=None, quote=True):
    if value is not None and len(value) > 0:
        if isinstance(value, tuple):
            param += b'*'
            value = utils.encode_rfc2231(value[2], value[0], value[1])
            return b'%s=%s' % (param, value)
        else:
            try:
                value.encode(b'ascii')
            except UnicodeEncodeError:
                param += b'*'
                value = utils.encode_rfc2231(value, b'utf-8', b'')
                return b'%s=%s' % (param, value)

            if quote or tspecials.search(value):
                return b'%s="%s"' % (param, utils.quote(value))
            return b'%s=%s' % (param, value)

    else:
        return param
    return


def _parseparam(s):
    s = b';' + str(s)
    plist = []
    while s[:1] == b';':
        s = s[1:]
        end = s.find(b';')
        while end > 0 and (s.count(b'"', 0, end) - s.count(b'\\"', 0, end)) % 2:
            end = s.find(b';', end + 1)

        if end < 0:
            end = len(s)
        f = s[:end]
        if b'=' in f:
            i = f.index(b'=')
            f = f[:i].strip().lower() + b'=' + f[i + 1:].strip()
        plist.append(f.strip())
        s = s[end:]

    return plist


def _unquotevalue(value):
    if isinstance(value, tuple):
        return (value[0], value[1], utils.unquote(value[2]))
    else:
        return utils.unquote(value)


class Message(object):

    def __init__(self, policy=compat32):
        self.policy = policy
        self._headers = list()
        self._unixfrom = None
        self._payload = None
        self._charset = None
        self.preamble = self.epilogue = None
        self.defects = []
        self._default_type = b'text/plain'
        return

    @as_native_str(encoding=b'utf-8')
    def __str__(self):
        return self.as_string()

    def as_string(self, unixfrom=False, maxheaderlen=0):
        from future.backports.email.generator import Generator
        fp = StringIO()
        g = Generator(fp, mangle_from_=False, maxheaderlen=maxheaderlen)
        g.flatten(self, unixfrom=unixfrom)
        return fp.getvalue()

    def is_multipart(self):
        return isinstance(self._payload, list)

    def set_unixfrom(self, unixfrom):
        self._unixfrom = unixfrom

    def get_unixfrom(self):
        return self._unixfrom

    def attach(self, payload):
        if self._payload is None:
            self._payload = [
             payload]
        else:
            self._payload.append(payload)
        return

    def get_payload(self, i=None, decode=False):
        if self.is_multipart():
            if decode:
                return
            else:
                if i is None:
                    return self._payload
                return self._payload[i]

        if i is not None and not isinstance(self._payload, list):
            raise TypeError(b'Expected list, got %s' % type(self._payload))
        payload = self._payload
        cte = str(self.get(b'content-transfer-encoding', b'')).lower()
        if isinstance(payload, str):
            payload = str(payload)
            if utils._has_surrogates(payload):
                bpayload = payload.encode(b'ascii', b'surrogateescape')
                if not decode:
                    try:
                        payload = bpayload.decode(self.get_param(b'charset', b'ascii'), b'replace')
                    except LookupError:
                        payload = bpayload.decode(b'ascii', b'replace')

            elif decode:
                try:
                    bpayload = payload.encode(b'ascii')
                except UnicodeError:
                    bpayload = payload.encode(b'raw-unicode-escape')

        if not decode:
            return payload
        else:
            if cte == b'quoted-printable':
                return utils._qdecode(bpayload)
            if cte == b'base64':
                value, defects = decode_b((b'').join(bpayload.splitlines()))
                for defect in defects:
                    self.policy.handle_defect(self, defect)

                return value
            if cte in ('x-uuencode', 'uuencode', 'uue', 'x-uue'):
                in_file = BytesIO(bpayload)
                out_file = BytesIO()
                try:
                    uu.decode(in_file, out_file, quiet=True)
                    return out_file.getvalue()
                except uu.Error:
                    return bpayload

            if isinstance(payload, str):
                return bpayload
            return payload

    def set_payload(self, payload, charset=None):
        self._payload = payload
        if charset is not None:
            self.set_charset(charset)
        return

    def set_charset(self, charset):
        if charset is None:
            self.del_param(b'charset')
            self._charset = None
            return
        else:
            if not isinstance(charset, Charset):
                charset = Charset(charset)
            self._charset = charset
            if b'MIME-Version' not in self:
                self.add_header(b'MIME-Version', b'1.0')
            if b'Content-Type' not in self:
                self.add_header(b'Content-Type', b'text/plain', charset=charset.get_output_charset())
            else:
                self.set_param(b'charset', charset.get_output_charset())
            if charset != charset.get_output_charset():
                self._payload = charset.body_encode(self._payload)
            if b'Content-Transfer-Encoding' not in self:
                cte = charset.get_body_encoding()
                try:
                    cte(self)
                except TypeError:
                    self._payload = charset.body_encode(self._payload)
                    self.add_header(b'Content-Transfer-Encoding', cte)

            return

    def get_charset(self):
        return self._charset

    def __len__(self):
        return len(self._headers)

    def __getitem__(self, name):
        return self.get(name)

    def __setitem__(self, name, val):
        max_count = self.policy.header_max_count(name)
        if max_count:
            lname = name.lower()
            found = 0
            for k, v in self._headers:
                if k.lower() == lname:
                    found += 1
                    if found >= max_count:
                        raise ValueError((b'There may be at most {} {} headers in a message').format(max_count, name))

        self._headers.append(self.policy.header_store_parse(name, val))

    def __delitem__(self, name):
        name = name.lower()
        newheaders = list()
        for k, v in self._headers:
            if k.lower() != name:
                newheaders.append((k, v))

        self._headers = newheaders

    def __contains__(self, name):
        return name.lower() in [ k.lower() for k, v in self._headers ]

    def __iter__(self):
        for field, value in self._headers:
            yield field

    def keys(self):
        return [ k for k, v in self._headers ]

    def values(self):
        return [ self.policy.header_fetch_parse(k, v) for k, v in self._headers
               ]

    def items(self):
        return [ (k, self.policy.header_fetch_parse(k, v)) for k, v in self._headers
               ]

    def get(self, name, failobj=None):
        name = name.lower()
        for k, v in self._headers:
            if k.lower() == name:
                return self.policy.header_fetch_parse(k, v)

        return failobj

    def set_raw(self, name, value):
        self._headers.append((name, value))

    def raw_items(self):
        return iter(self._headers.copy())

    def get_all(self, name, failobj=None):
        values = []
        name = name.lower()
        for k, v in self._headers:
            if k.lower() == name:
                values.append(self.policy.header_fetch_parse(k, v))

        if not values:
            return failobj
        return values

    def add_header(self, _name, _value, **_params):
        parts = []
        for k, v in _params.items():
            if v is None:
                parts.append(k.replace(b'_', b'-'))
            else:
                parts.append(_formatparam(k.replace(b'_', b'-'), v))

        if _value is not None:
            parts.insert(0, _value)
        self[_name] = SEMISPACE.join(parts)
        return

    def replace_header(self, _name, _value):
        _name = _name.lower()
        for i, (k, v) in zip(range(len(self._headers)), self._headers):
            if k.lower() == _name:
                self._headers[i] = self.policy.header_store_parse(k, _value)
                break
        else:
            raise KeyError(_name)

    def get_content_type(self):
        missing = object()
        value = self.get(b'content-type', missing)
        if value is missing:
            return self.get_default_type()
        ctype = _splitparam(value)[0].lower()
        if ctype.count(b'/') != 1:
            return b'text/plain'
        return ctype

    def get_content_maintype(self):
        ctype = self.get_content_type()
        return ctype.split(b'/')[0]

    def get_content_subtype(self):
        ctype = self.get_content_type()
        return ctype.split(b'/')[1]

    def get_default_type(self):
        return self._default_type

    def set_default_type(self, ctype):
        self._default_type = ctype

    def _get_params_preserve(self, failobj, header):
        missing = object()
        value = self.get(header, missing)
        if value is missing:
            return failobj
        params = []
        for p in _parseparam(value):
            try:
                name, val = p.split(b'=', 1)
                name = name.strip()
                val = val.strip()
            except ValueError:
                name = p.strip()
                val = b''

            params.append((name, val))

        params = utils.decode_params(params)
        return params

    def get_params(self, failobj=None, header=b'content-type', unquote=True):
        missing = object()
        params = self._get_params_preserve(missing, header)
        if params is missing:
            return failobj
        else:
            if unquote:
                return [ (k, _unquotevalue(v)) for k, v in params ]
            return params

    def get_param(self, param, failobj=None, header=b'content-type', unquote=True):
        if header not in self:
            return failobj
        for k, v in self._get_params_preserve(failobj, header):
            if k.lower() == param.lower():
                if unquote:
                    return _unquotevalue(v)
                else:
                    return v

        return failobj

    def set_param(self, param, value, header=b'Content-Type', requote=True, charset=None, language=b''):
        if not isinstance(value, tuple) and charset:
            value = (
             charset, language, value)
        if header not in self and header.lower() == b'content-type':
            ctype = b'text/plain'
        else:
            ctype = self.get(header)
        if not self.get_param(param, header=header):
            if not ctype:
                ctype = _formatparam(param, value, requote)
            else:
                ctype = SEMISPACE.join([
                 ctype, _formatparam(param, value, requote)])
        else:
            ctype = b''
            for old_param, old_value in self.get_params(header=header, unquote=requote):
                append_param = b''
                if old_param.lower() == param.lower():
                    append_param = _formatparam(param, value, requote)
                else:
                    append_param = _formatparam(old_param, old_value, requote)
                if not ctype:
                    ctype = append_param
                else:
                    ctype = SEMISPACE.join([ctype, append_param])

        if ctype != self.get(header):
            del self[header]
            self[header] = ctype

    def del_param(self, param, header=b'content-type', requote=True):
        if header not in self:
            return
        new_ctype = b''
        for p, v in self.get_params(header=header, unquote=requote):
            if p.lower() != param.lower():
                if not new_ctype:
                    new_ctype = _formatparam(p, v, requote)
                else:
                    new_ctype = SEMISPACE.join([new_ctype,
                     _formatparam(p, v, requote)])

        if new_ctype != self.get(header):
            del self[header]
            self[header] = new_ctype

    def set_type(self, type, header=b'Content-Type', requote=True):
        if not type.count(b'/') == 1:
            raise ValueError
        if header.lower() == b'content-type':
            del self[b'mime-version']
            self[b'MIME-Version'] = b'1.0'
        if header not in self:
            self[header] = type
            return
        params = self.get_params(header=header, unquote=requote)
        del self[header]
        self[header] = type
        for p, v in params[1:]:
            self.set_param(p, v, header, requote)

    def get_filename(self, failobj=None):
        missing = object()
        filename = self.get_param(b'filename', missing, b'content-disposition')
        if filename is missing:
            filename = self.get_param(b'name', missing, b'content-type')
        if filename is missing:
            return failobj
        return utils.collapse_rfc2231_value(filename).strip()

    def get_boundary(self, failobj=None):
        missing = object()
        boundary = self.get_param(b'boundary', missing)
        if boundary is missing:
            return failobj
        return utils.collapse_rfc2231_value(boundary).rstrip()

    def set_boundary(self, boundary):
        missing = object()
        params = self._get_params_preserve(missing, b'content-type')
        if params is missing:
            raise errors.HeaderParseError(b'No Content-Type header found')
        newparams = list()
        foundp = False
        for pk, pv in params:
            if pk.lower() == b'boundary':
                newparams.append((b'boundary', b'"%s"' % boundary))
                foundp = True
            else:
                newparams.append((pk, pv))

        if not foundp:
            newparams.append((b'boundary', b'"%s"' % boundary))
        newheaders = list()
        for h, v in self._headers:
            if h.lower() == b'content-type':
                parts = list()
                for k, v in newparams:
                    if v == b'':
                        parts.append(k)
                    else:
                        parts.append(b'%s=%s' % (k, v))

                val = SEMISPACE.join(parts)
                newheaders.append(self.policy.header_store_parse(h, val))
            else:
                newheaders.append((h, v))

        self._headers = newheaders

    def get_content_charset(self, failobj=None):
        missing = object()
        charset = self.get_param(b'charset', missing)
        if charset is missing:
            return failobj
        if isinstance(charset, tuple):
            pcharset = charset[0] or b'us-ascii'
            try:
                as_bytes = charset[2].encode(b'raw-unicode-escape')
                charset = str(as_bytes, pcharset)
            except (LookupError, UnicodeError):
                charset = charset[2]

        try:
            charset.encode(b'us-ascii')
        except UnicodeError:
            return failobj

        return charset.lower()

    def get_charsets(self, failobj=None):
        return [ part.get_content_charset(failobj) for part in self.walk() ]

    from future.backports.email.iterators import walk