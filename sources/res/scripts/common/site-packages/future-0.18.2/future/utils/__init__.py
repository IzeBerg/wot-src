import types, sys, numbers, functools, copy, inspect
PY3 = sys.version_info[0] >= 3
PY34_PLUS = sys.version_info[0:2] >= (3, 4)
PY35_PLUS = sys.version_info[0:2] >= (3, 5)
PY36_PLUS = sys.version_info[0:2] >= (3, 6)
PY2 = sys.version_info[0] == 2
PY26 = sys.version_info[0:2] == (2, 6)
PY27 = sys.version_info[0:2] == (2, 7)
PYPY = hasattr(sys, 'pypy_translation_info')

def python_2_unicode_compatible(cls):
    if not PY3:
        cls.__unicode__ = cls.__str__
        cls.__str__ = lambda self: self.__unicode__().encode('utf-8')
    return cls


def with_metaclass(meta, *bases):

    class metaclass(meta):
        __call__ = type.__call__
        __init__ = type.__init__

        def __new__(cls, name, this_bases, d):
            if this_bases is None:
                return type.__new__(cls, name, (), d)
            else:
                return meta(name, bases, d)

    return metaclass('temporary_class', None, {})


if PY3:

    def bchr(s):
        return bytes([s])


    def bstr(s):
        if isinstance(s, str):
            return bytes(s, 'latin-1')
        else:
            return bytes(s)


    def bord(s):
        return s


    string_types = (
     str,)
    integer_types = (int,)
    class_types = (type,)
    text_type = str
    binary_type = bytes
else:

    def bchr(s):
        return chr(s)


    def bstr(s):
        return str(s)


    def bord(s):
        return ord(s)


    string_types = (
     basestring,)
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str
if PY3:

    def tobytes(s):
        if isinstance(s, bytes):
            return s
        else:
            if isinstance(s, str):
                return s.encode('latin-1')
            return bytes(s)


else:

    def tobytes(s):
        if isinstance(s, unicode):
            return s.encode('latin-1')
        else:
            return ('').join(s)


tobytes.__doc__ = '\n    Encodes to latin-1 (where the first 256 chars are the same as\n    ASCII.)\n    '
if PY3:

    def native_str_to_bytes(s, encoding='utf-8'):
        return s.encode(encoding)


    def bytes_to_native_str(b, encoding='utf-8'):
        return b.decode(encoding)


    def text_to_native_str(t, encoding=None):
        return t


else:

    def native_str_to_bytes(s, encoding=None):
        from future.types import newbytes
        return newbytes(s)


    def bytes_to_native_str(b, encoding=None):
        return native(b)


    def text_to_native_str(t, encoding='ascii'):
        return unicode(t).encode(encoding)


native_str_to_bytes.__doc__ = '\n    On Py3, returns an encoded string.\n    On Py2, returns a newbytes type, ignoring the ``encoding`` argument.\n    '
if PY3:

    def lrange(*args, **kwargs):
        return list(range(*args, **kwargs))


    def lzip(*args, **kwargs):
        return list(zip(*args, **kwargs))


    def lmap(*args, **kwargs):
        return list(map(*args, **kwargs))


    def lfilter(*args, **kwargs):
        return list(filter(*args, **kwargs))


else:
    import __builtin__
    lrange = __builtin__.range
    lzip = __builtin__.zip
    lmap = __builtin__.map
    lfilter = __builtin__.filter

def isidentifier(s, dotted=False):
    if dotted:
        return all(isidentifier(a) for a in s.split('.'))
    else:
        if PY3:
            return s.isidentifier()
        import re
        _name_re = re.compile('[a-zA-Z_][a-zA-Z0-9_]*$')
        return bool(_name_re.match(s))


def viewitems(obj, **kwargs):
    func = getattr(obj, 'viewitems', None)
    if not func:
        func = obj.items
    return func(**kwargs)


def viewkeys(obj, **kwargs):
    func = getattr(obj, 'viewkeys', None)
    if not func:
        func = obj.keys
    return func(**kwargs)


def viewvalues(obj, **kwargs):
    func = getattr(obj, 'viewvalues', None)
    if not func:
        func = obj.values
    return func(**kwargs)


def iteritems(obj, **kwargs):
    func = getattr(obj, 'iteritems', None)
    if not func:
        func = obj.items
    return func(**kwargs)


def iterkeys(obj, **kwargs):
    func = getattr(obj, 'iterkeys', None)
    if not func:
        func = obj.keys
    return func(**kwargs)


def itervalues(obj, **kwargs):
    func = getattr(obj, 'itervalues', None)
    if not func:
        func = obj.values
    return func(**kwargs)


def bind_method(cls, name, func):
    if not PY3:
        setattr(cls, name, types.MethodType(func, None, cls))
    else:
        setattr(cls, name, func)
    return


def getexception():
    return sys.exc_info()[1]


def _get_caller_globals_and_locals():
    caller_frame = inspect.stack()[2]
    myglobals = caller_frame[0].f_globals
    mylocals = caller_frame[0].f_locals
    return (myglobals, mylocals)


def _repr_strip(mystring):
    r = repr(mystring)
    if r.startswith("'") and r.endswith("'"):
        return r[1:-1]
    else:
        return r


if PY3:

    def raise_from(exc, cause):
        myglobals, mylocals = _get_caller_globals_and_locals()
        myglobals = myglobals.copy()
        myglobals['__python_future_raise_from_exc'] = exc
        myglobals['__python_future_raise_from_cause'] = cause
        execstr = 'raise __python_future_raise_from_exc from __python_future_raise_from_cause'
        exec execstr in myglobals, mylocals


    def raise_(tp, value=None, tb=None):
        if isinstance(tp, BaseException):
            if value is not None:
                raise TypeError('instance exception may not have a separate value')
            exc = tp
        elif isinstance(tp, type) and not issubclass(tp, BaseException):
            raise TypeError('class must derive from BaseException, not %s' % tp.__name__)
        elif isinstance(value, tp):
            exc = value
        elif isinstance(value, tuple):
            exc = tp(*value)
        elif value is None:
            exc = tp()
        else:
            exc = tp(value)
        if exc.__traceback__ is not tb:
            raise exc.with_traceback(tb)
        raise exc
        return


    def raise_with_traceback(exc, traceback=Ellipsis):
        if traceback == Ellipsis:
            _, _, traceback = sys.exc_info()
        raise exc.with_traceback(traceback)


else:

    def raise_from(exc, cause):
        if isinstance(exc, type) and issubclass(exc, Exception):
            e = exc()
        else:
            e = exc
        e.__suppress_context__ = False
        if isinstance(cause, type) and issubclass(cause, Exception):
            e.__cause__ = cause()
            e.__cause__.__traceback__ = sys.exc_info()[2]
            e.__suppress_context__ = True
        elif cause is None:
            e.__cause__ = None
            e.__suppress_context__ = True
        elif isinstance(cause, BaseException):
            e.__cause__ = cause
            object.__setattr__(e.__cause__, '__traceback__', sys.exc_info()[2])
            e.__suppress_context__ = True
        else:
            raise TypeError('exception causes must derive from BaseException')
        e.__context__ = sys.exc_info()[1]
        raise e
        return


    exec ('\ndef raise_(tp, value=None, tb=None):\n    raise tp, value, tb\n\ndef raise_with_traceback(exc, traceback=Ellipsis):\n    if traceback == Ellipsis:\n        _, _, traceback = sys.exc_info()\n    raise exc, None, traceback\n').strip()
raise_with_traceback.__doc__ = 'Raise exception with existing traceback.\nIf traceback is not passed, uses sys.exc_info() to get traceback.'
reraise = raise_

def implements_iterator(cls):
    if PY3:
        return cls
    else:
        cls.next = cls.__next__
        del cls.__next__
        return cls


if PY3:
    get_next = lambda x: x.next
else:
    get_next = lambda x: x.__next__

def encode_filename(filename):
    if PY3:
        return filename
    else:
        if isinstance(filename, unicode):
            return filename.encode('utf-8')
        return filename


def is_new_style(cls):
    return hasattr(cls, '__class__') and ('__dict__' in dir(cls) or hasattr(cls, '__slots__'))


native_str = str
native_bytes = bytes

def istext(obj):
    return isinstance(obj, type(''))


def isbytes(obj):
    return isinstance(obj, type(''))


def isnewbytes(obj):
    return type(obj).__name__ == 'newbytes'


def isint(obj):
    return isinstance(obj, numbers.Integral)


def native(obj):
    if hasattr(obj, '__native__'):
        return obj.__native__()
    else:
        return obj


if PY3:
    import builtins
    exec_ = getattr(builtins, 'exec')
else:

    def exec_(code, globs=None, locs=None):
        if globs is None:
            frame = sys._getframe(1)
            globs = frame.f_globals
            if locs is None:
                locs = frame.f_locals
            del frame
        elif locs is None:
            locs = globs
        exec 'exec code in globs, locs'
        return


def old_div(a, b):
    if isinstance(a, numbers.Integral) and isinstance(b, numbers.Integral):
        return a // b
    else:
        return a / b


def as_native_str(encoding='utf-8'):
    if PY3:
        return lambda f: f
    else:

        def encoder(f):

            @functools.wraps(f)
            def wrapper(*args, **kwargs):
                return f(*args, **kwargs).encode(encoding=encoding)

            return wrapper

        return encoder


try:
    dict.iteritems
except AttributeError:

    def listvalues(d):
        return list(d.values())


    def listitems(d):
        return list(d.items())


else:

    def listvalues(d):
        return d.values()


    def listitems(d):
        return d.items()


if PY3:

    def ensure_new_type(obj):
        return obj


else:

    def ensure_new_type(obj):
        from future.types.newbytes import newbytes
        from future.types.newstr import newstr
        from future.types.newint import newint
        from future.types.newdict import newdict
        native_type = type(native(obj))
        if issubclass(native_type, type(obj)):
            if native_type == str:
                return newbytes(obj)
            else:
                if native_type == unicode:
                    return newstr(obj)
                if native_type == int:
                    return newint(obj)
                if native_type == long:
                    return newint(obj)
                if native_type == dict:
                    return newdict(obj)
                return obj

        else:
            return obj


__all__ = ['PY2', 'PY26', 'PY3', 'PYPY',
 'as_native_str', 'binary_type', 'bind_method', 'bord', 'bstr',
 'bytes_to_native_str', 'class_types', 'encode_filename',
 'ensure_new_type', 'exec_', 'get_next', 'getexception',
 'implements_iterator', 'integer_types', 'is_new_style', 'isbytes',
 'isidentifier', 'isint', 'isnewbytes', 'istext', 'iteritems',
 'iterkeys', 'itervalues', 'lfilter', 'listitems', 'listvalues',
 'lmap', 'lrange', 'lzip', 'native', 'native_bytes', 'native_str',
 'native_str_to_bytes', 'old_div',
 'python_2_unicode_compatible', 'raise_',
 'raise_with_traceback', 'reraise', 'string_types',
 'text_to_native_str', 'text_type', 'tobytes', 'viewitems',
 'viewkeys', 'viewvalues', 'with_metaclass']