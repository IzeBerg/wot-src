from numbers import Integral
import string, copy
from future.utils import istext, isbytes, PY2, PY3, with_metaclass
from future.types import no, issubset
from future.types.newobject import newobject
if PY2:
    from collections import Iterable
else:
    from collections.abc import Iterable
_builtin_bytes = bytes
if PY3:
    unicode = str

class BaseNewBytes(type):

    def __instancecheck__(cls, instance):
        if cls == newbytes:
            return isinstance(instance, _builtin_bytes)
        else:
            return issubclass(instance.__class__, cls)


def _newchr(x):
    if isinstance(x, str):
        return x.encode('ascii')
    else:
        return chr(x)


class newbytes(with_metaclass(BaseNewBytes, _builtin_bytes)):

    def __new__(cls, *args, **kwargs):
        encoding = None
        errors = None
        if len(args) == 0:
            return super(newbytes, cls).__new__(cls)
        else:
            if len(args) >= 2:
                args = list(args)
                if len(args) == 3:
                    errors = args.pop()
                encoding = args.pop()
            if type(args[0]) == newbytes:
                return args[0]
            if isinstance(args[0], _builtin_bytes):
                value = args[0]
            else:
                if isinstance(args[0], unicode):
                    try:
                        if 'encoding' in kwargs:
                            encoding = kwargs['encoding']
                        if 'errors' in kwargs:
                            errors = kwargs['errors']
                    except AssertionError:
                        raise TypeError('Argument given by name and position')

                    if encoding is None:
                        raise TypeError('unicode string argument without an encoding')
                    newargs = [
                     encoding]
                    if errors is not None:
                        newargs.append(errors)
                    value = args[0].encode(*newargs)
                elif hasattr(args[0], '__bytes__'):
                    value = args[0].__bytes__()
                elif isinstance(args[0], Iterable):
                    if len(args[0]) == 0:
                        value = ''
                    else:
                        try:
                            value = bytearray([ _newchr(x) for x in args[0] ])
                        except:
                            raise ValueError('bytes must be in range(0, 256)')

                elif isinstance(args[0], Integral):
                    if args[0] < 0:
                        raise ValueError('negative count')
                    value = '\x00' * args[0]
                else:
                    value = args[0]
                if type(value) == newbytes:
                    return copy.copy(value)
            return super(newbytes, cls).__new__(cls, value)
            return

    def __repr__(self):
        return 'b' + super(newbytes, self).__repr__()

    def __str__(self):
        return 'b' + ("'{0}'").format(super(newbytes, self).__str__())

    def __getitem__(self, y):
        value = super(newbytes, self).__getitem__(y)
        if isinstance(y, Integral):
            return ord(value)
        else:
            return newbytes(value)

    def __getslice__(self, *args):
        return self.__getitem__(slice(*args))

    def __contains__(self, key):
        if isinstance(key, int):
            newbyteskey = newbytes([key])
        elif type(key) == newbytes:
            newbyteskey = key
        else:
            newbyteskey = newbytes(key)
        return issubset(list(newbyteskey), list(self))

    @no(unicode)
    def __add__(self, other):
        return newbytes(super(newbytes, self).__add__(other))

    @no(unicode)
    def __radd__(self, left):
        return newbytes(left) + self

    @no(unicode)
    def __mul__(self, other):
        return newbytes(super(newbytes, self).__mul__(other))

    @no(unicode)
    def __rmul__(self, other):
        return newbytes(super(newbytes, self).__rmul__(other))

    def __mod__(self, vals):
        if isinstance(vals, newbytes):
            vals = _builtin_bytes.__str__(vals)
        elif isinstance(vals, tuple):
            newvals = []
            for v in vals:
                if isinstance(v, newbytes):
                    v = _builtin_bytes.__str__(v)
                newvals.append(v)

            vals = tuple(newvals)
        elif hasattr(vals.__class__, '__getitem__') and hasattr(vals.__class__, 'iteritems'):
            for k, v in vals.iteritems():
                if isinstance(v, newbytes):
                    vals[k] = _builtin_bytes.__str__(v)

        return _builtin_bytes.__mod__(self, vals)

    def __imod__(self, other):
        return self.__mod__(other)

    def join(self, iterable_of_bytes):
        errmsg = 'sequence item {0}: expected bytes, {1} found'
        if isbytes(iterable_of_bytes) or istext(iterable_of_bytes):
            raise TypeError(errmsg.format(0, type(iterable_of_bytes)))
        for i, item in enumerate(iterable_of_bytes):
            if istext(item):
                raise TypeError(errmsg.format(i, type(item)))

        return newbytes(super(newbytes, self).join(iterable_of_bytes))

    @classmethod
    def fromhex(cls, string):
        return cls(string.replace(' ', '').decode('hex'))

    @no(unicode)
    def find(self, sub, *args):
        return super(newbytes, self).find(sub, *args)

    @no(unicode)
    def rfind(self, sub, *args):
        return super(newbytes, self).rfind(sub, *args)

    @no(unicode, (1, 2))
    def replace(self, old, new, *args):
        return newbytes(super(newbytes, self).replace(old, new, *args))

    def encode(self, *args):
        raise AttributeError('encode method has been disabled in newbytes')

    def decode(self, encoding='utf-8', errors='strict'):
        from future.types.newstr import newstr
        if errors == 'surrogateescape':
            from future.utils.surrogateescape import register_surrogateescape
            register_surrogateescape()
        return newstr(super(newbytes, self).decode(encoding, errors))

    @no(unicode)
    def startswith(self, prefix, *args):
        return super(newbytes, self).startswith(prefix, *args)

    @no(unicode)
    def endswith(self, prefix, *args):
        return super(newbytes, self).endswith(prefix, *args)

    @no(unicode)
    def split(self, sep=None, maxsplit=-1):
        parts = super(newbytes, self).split(sep, maxsplit)
        return [ newbytes(part) for part in parts ]

    def splitlines(self, keepends=False):
        parts = super(newbytes, self).splitlines(keepends)
        return [ newbytes(part) for part in parts ]

    @no(unicode)
    def rsplit(self, sep=None, maxsplit=-1):
        parts = super(newbytes, self).rsplit(sep, maxsplit)
        return [ newbytes(part) for part in parts ]

    @no(unicode)
    def partition(self, sep):
        parts = super(newbytes, self).partition(sep)
        return tuple(newbytes(part) for part in parts)

    @no(unicode)
    def rpartition(self, sep):
        parts = super(newbytes, self).rpartition(sep)
        return tuple(newbytes(part) for part in parts)

    @no(unicode, (1, ))
    def rindex(self, sub, *args):
        pos = self.rfind(sub, *args)
        if pos == -1:
            raise ValueError('substring not found')

    @no(unicode)
    def index(self, sub, *args):
        if isinstance(sub, int):
            if len(args) == 0:
                start, end = 0, len(self)
            elif len(args) == 1:
                start = args[0]
            elif len(args) == 2:
                start, end = args
            else:
                raise TypeError('takes at most 3 arguments')
            return list(self)[start:end].index(sub)
        if not isinstance(sub, bytes):
            try:
                sub = self.__class__(sub)
            except (TypeError, ValueError):
                raise TypeError("can't convert sub to bytes")

        try:
            return super(newbytes, self).index(sub, *args)
        except ValueError:
            raise ValueError('substring not found')

    def __eq__(self, other):
        if isinstance(other, (_builtin_bytes, bytearray)):
            return super(newbytes, self).__eq__(other)
        else:
            return False

    def __ne__(self, other):
        if isinstance(other, _builtin_bytes):
            return super(newbytes, self).__ne__(other)
        else:
            return True

    unorderable_err = 'unorderable types: bytes() and {0}'

    def __lt__(self, other):
        if isinstance(other, _builtin_bytes):
            return super(newbytes, self).__lt__(other)
        raise TypeError(self.unorderable_err.format(type(other)))

    def __le__(self, other):
        if isinstance(other, _builtin_bytes):
            return super(newbytes, self).__le__(other)
        raise TypeError(self.unorderable_err.format(type(other)))

    def __gt__(self, other):
        if isinstance(other, _builtin_bytes):
            return super(newbytes, self).__gt__(other)
        raise TypeError(self.unorderable_err.format(type(other)))

    def __ge__(self, other):
        if isinstance(other, _builtin_bytes):
            return super(newbytes, self).__ge__(other)
        raise TypeError(self.unorderable_err.format(type(other)))

    def __native__(self):
        return super(newbytes, self).__str__()

    def __getattribute__(self, name):
        if name in ('encode', 'encode'):
            raise AttributeError('encode method has been disabled in newbytes')
        return super(newbytes, self).__getattribute__(name)

    @no(unicode)
    def rstrip(self, bytes_to_strip=None):
        return newbytes(super(newbytes, self).rstrip(bytes_to_strip))

    @no(unicode)
    def strip(self, bytes_to_strip=None):
        return newbytes(super(newbytes, self).strip(bytes_to_strip))

    def lower(self):
        return newbytes(super(newbytes, self).lower())

    @no(unicode)
    def upper(self):
        return newbytes(super(newbytes, self).upper())

    @classmethod
    @no(unicode)
    def maketrans(cls, frm, to):
        return newbytes(string.maketrans(frm, to))


__all__ = [
 'newbytes']