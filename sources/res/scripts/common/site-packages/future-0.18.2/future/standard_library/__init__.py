from __future__ import absolute_import, division, print_function
import sys, logging, imp, contextlib, types, copy, os
flog = logging.getLogger('future_stdlib')
_formatter = logging.Formatter(logging.BASIC_FORMAT)
_handler = logging.StreamHandler()
_handler.setFormatter(_formatter)
flog.addHandler(_handler)
flog.setLevel(logging.WARN)
from future.utils import PY2, PY3
REPLACED_MODULES = set(['test', 'urllib', 'pickle', 'dbm'])
RENAMES = {'__builtin__': 'builtins', 
   'copy_reg': 'copyreg', 
   'Queue': 'queue', 
   'future.moves.socketserver': 'socketserver', 
   'ConfigParser': 'configparser', 
   'repr': 'reprlib', 
   '_winreg': 'winreg', 
   'thread': '_thread', 
   'dummy_thread': '_dummy_thread', 
   'future.moves.xmlrpc': 'xmlrpc', 
   'future.moves.html': 'html', 
   'future.moves.http': 'http', 
   'future.moves._markupbase': '_markupbase'}
MOVES = [
 ('collections', 'UserList', 'UserList', 'UserList'),
 ('collections', 'UserDict', 'UserDict', 'UserDict'),
 ('collections', 'UserString', 'UserString', 'UserString'),
 ('collections', 'ChainMap', 'future.backports.misc', 'ChainMap'),
 ('itertools', 'filterfalse', 'itertools', 'ifilterfalse'),
 ('itertools', 'zip_longest', 'itertools', 'izip_longest'),
 ('sys', 'intern', '__builtin__', 'intern'),
 ('re', 'ASCII', 'stat', 'ST_MODE'),
 ('base64', 'encodebytes', 'base64', 'encodestring'),
 ('base64', 'decodebytes', 'base64', 'decodestring'),
 ('subprocess', 'getoutput', 'commands', 'getoutput'),
 ('subprocess', 'getstatusoutput', 'commands', 'getstatusoutput'),
 ('subprocess', 'check_output', 'future.backports.misc', 'check_output'),
 ('math', 'ceil', 'future.backports.misc', 'ceil'),
 ('collections', 'OrderedDict', 'future.backports.misc', 'OrderedDict'),
 ('collections', 'Counter', 'future.backports.misc', 'Counter'),
 ('collections', 'ChainMap', 'future.backports.misc', 'ChainMap'),
 ('itertools', 'count', 'future.backports.misc', 'count'),
 ('reprlib', 'recursive_repr', 'future.backports.misc', 'recursive_repr'),
 ('functools', 'cmp_to_key', 'future.backports.misc', 'cmp_to_key')]

class RenameImport(object):
    RENAMER = True

    def __init__(self, old_to_new):
        self.old_to_new = old_to_new
        both = set(old_to_new.keys()) & set(old_to_new.values())
        self.new_to_old = dict((new, old) for old, new in old_to_new.items())

    def find_module(self, fullname, path=None):
        new_base_names = set([ s.split('.')[0] for s in self.new_to_old ])
        if fullname in new_base_names:
            return self
        else:
            return

    def load_module(self, name):
        path = None
        if name in sys.modules:
            return sys.modules[name]
        else:
            if name in self.new_to_old:
                oldname = self.new_to_old[name]
                module = self._find_and_load_module(oldname)
            else:
                module = self._find_and_load_module(name)
            sys.modules[name] = module
            return module

    def _find_and_load_module(self, name, path=None):
        bits = name.split('.')
        while len(bits) > 1:
            packagename = bits.pop(0)
            package = self._find_and_load_module(packagename, path)
            try:
                path = package.__path__
            except AttributeError:
                flog.debug(('Package {0} has no __path__.').format(package))
                if name in sys.modules:
                    return sys.modules[name]
                flog.debug('What to do here?')

        name = bits[0]
        module_info = imp.find_module(name, path)
        return imp.load_module(name, *module_info)


class hooks(object):

    def __enter__(self):
        self.old_sys_modules = copy.copy(sys.modules)
        self.hooks_were_installed = detect_hooks()
        install_hooks()
        return self

    def __exit__(self, *args):
        if not self.hooks_were_installed:
            remove_hooks()


if PY2:
    pass

def is_py2_stdlib_module(m):
    if PY3:
        return False
    if 'stdlib_path' not in is_py2_stdlib_module.__dict__:
        stdlib_files = [
         contextlib.__file__, os.__file__, copy.__file__]
        stdlib_paths = [ os.path.split(f)[0] for f in stdlib_files ]
        if not len(set(stdlib_paths)) == 1:
            flog.warn('Multiple locations found for the Python standard library: %s' % stdlib_paths)
        is_py2_stdlib_module.stdlib_path = stdlib_paths[0]
    if m.__name__ in sys.builtin_module_names:
        return True
    if hasattr(m, '__file__'):
        modpath = os.path.split(m.__file__)
        if modpath[0].startswith(is_py2_stdlib_module.stdlib_path) and 'site-packages' not in modpath[0]:
            return True
    return False


def scrub_py2_sys_modules():
    if PY3:
        return {}
    scrubbed = {}
    for modulename in REPLACED_MODULES & set(RENAMES.keys()):
        if modulename not in sys.modules:
            continue
        module = sys.modules[modulename]
        if is_py2_stdlib_module(module):
            flog.debug(('Deleting (Py2) {} from sys.modules').format(modulename))
            scrubbed[modulename] = sys.modules[modulename]
            del sys.modules[modulename]

    return scrubbed


def scrub_future_sys_modules():
    return {}


class suspend_hooks(object):

    def __enter__(self):
        self.hooks_were_installed = detect_hooks()
        remove_hooks()
        return self

    def __exit__(self, *args):
        if self.hooks_were_installed:
            install_hooks()


def restore_sys_modules(scrubbed):
    clash = set(sys.modules) & set(scrubbed)
    if len(clash) != 0:
        first = list(clash)[0]
        raise ImportError(('future module {} clashes with Py2 module').format(first))
    sys.modules.update(scrubbed)


def install_aliases():
    if PY3:
        return
    for newmodname, newobjname, oldmodname, oldobjname in MOVES:
        __import__(newmodname)
        newmod = sys.modules[newmodname]
        __import__(oldmodname)
        oldmod = sys.modules[oldmodname]
        obj = getattr(oldmod, oldobjname)
        setattr(newmod, newobjname, obj)

    import urllib
    from future.backports.urllib import request
    from future.backports.urllib import response
    from future.backports.urllib import parse
    from future.backports.urllib import error
    from future.backports.urllib import robotparser
    urllib.request = request
    urllib.response = response
    urllib.parse = parse
    urllib.error = error
    urllib.robotparser = robotparser
    sys.modules['urllib.request'] = request
    sys.modules['urllib.response'] = response
    sys.modules['urllib.parse'] = parse
    sys.modules['urllib.error'] = error
    sys.modules['urllib.robotparser'] = robotparser
    try:
        import test
    except ImportError:
        pass

    try:
        from future.moves.test import support
    except ImportError:
        pass
    else:
        test.support = support
        sys.modules['test.support'] = support

    try:
        import dbm
    except ImportError:
        pass
    else:
        from future.moves.dbm import dumb
        dbm.dumb = dumb
        sys.modules['dbm.dumb'] = dumb
        try:
            from future.moves.dbm import gnu
        except ImportError:
            pass
        else:
            dbm.gnu = gnu
            sys.modules['dbm.gnu'] = gnu

        try:
            from future.moves.dbm import ndbm
        except ImportError:
            pass
        else:
            dbm.ndbm = ndbm
            sys.modules['dbm.ndbm'] = ndbm


def install_hooks():
    if PY3:
        return
    install_aliases()
    flog.debug(('sys.meta_path was: {0}').format(sys.meta_path))
    flog.debug('Installing hooks ...')
    newhook = RenameImport(RENAMES)
    if not detect_hooks():
        sys.meta_path.append(newhook)
    flog.debug(('sys.meta_path is now: {0}').format(sys.meta_path))


def enable_hooks():
    install_hooks()


def remove_hooks(scrub_sys_modules=False):
    if PY3:
        return
    flog.debug('Uninstalling hooks ...')
    for i, hook in list(enumerate(sys.meta_path))[::-1]:
        if hasattr(hook, 'RENAMER'):
            del sys.meta_path[i]

    if scrub_sys_modules:
        scrub_future_sys_modules()


def disable_hooks():
    remove_hooks()


def detect_hooks():
    flog.debug('Detecting hooks ...')
    present = any([ hasattr(hook, 'RENAMER') for hook in sys.meta_path ])
    if present:
        flog.debug('Detected.')
    else:
        flog.debug('Not detected.')
    return present


if not hasattr(sys, 'py2_modules'):
    sys.py2_modules = {}

def cache_py2_modules():
    if len(sys.py2_modules) != 0:
        return
    import urllib
    sys.py2_modules['urllib'] = urllib
    import email
    sys.py2_modules['email'] = email
    import pickle
    sys.py2_modules['pickle'] = pickle


def import_(module_name, backport=False):
    import importlib
    if PY3:
        return __import__(module_name)
    else:
        if backport:
            prefix = 'future.backports'
        else:
            prefix = 'future.moves'
        parts = prefix.split('.') + module_name.split('.')
        modules = []
        for i, part in enumerate(parts):
            sofar = ('.').join(parts[:i + 1])
            modules.append(importlib.import_module(sofar))

        for i, part in reversed(list(enumerate(parts))):
            if i == 0:
                break
            setattr(modules[(i - 1)], part, modules[i])

        return modules[2]


def from_import(module_name, *symbol_names, **kwargs):
    if PY3:
        return __import__(module_name)
    else:
        if 'backport' in kwargs and bool(kwargs['backport']):
            prefix = 'future.backports'
        else:
            prefix = 'future.moves'
        parts = prefix.split('.') + module_name.split('.')
        module = importlib.import_module(prefix + '.' + module_name)
        output = [ getattr(module, name) for name in symbol_names ]
        if len(output) == 1:
            return output[0]
        return output


class exclude_local_folder_imports(object):

    def __init__(self, *args):
        self.module_names = args
        if any([ '.' in m for m in self.module_names ]):
            raise NotImplementedError('Dotted module names are not supported')

    def __enter__(self):
        self.old_sys_path = copy.copy(sys.path)
        self.old_sys_modules = copy.copy(sys.modules)
        if sys.version_info[0] < 3:
            return
        FUTURE_SOURCE_SUBFOLDERS = [
         'future', 'past', 'libfuturize', 'libpasteurize', 'builtins']
        for folder in self.old_sys_path:
            if all([ os.path.exists(os.path.join(folder, subfolder)) for subfolder in FUTURE_SOURCE_SUBFOLDERS
                   ]):
                sys.path.remove(folder)

        for m in self.module_names:
            try:
                module = __import__(m, level=0)
            except ImportError:
                pass

    def __exit__(self, *args):
        sys.path = self.old_sys_path
        for m in set(self.old_sys_modules.keys()) - set(sys.modules.keys()):
            sys.modules[m] = self.old_sys_modules[m]


TOP_LEVEL_MODULES = ['builtins',
 'copyreg',
 'html',
 'http',
 'queue',
 'reprlib',
 'socketserver',
 'test',
 'tkinter',
 'winreg',
 'xmlrpc',
 '_dummy_thread',
 '_markupbase',
 '_thread']

def import_top_level_modules():
    with exclude_local_folder_imports(*TOP_LEVEL_MODULES):
        for m in TOP_LEVEL_MODULES:
            try:
                __import__(m)
            except ImportError:
                pass