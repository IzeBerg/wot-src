from __future__ import absolute_import, print_function, unicode_literals
import future.utils
from future import __version__
import sys, logging, optparse, os
from lib2to3.main import warn, StdoutRefactoringTool
from lib2to3 import refactor
from libfuturize.fixes import lib2to3_fix_names_stage1, lib2to3_fix_names_stage2, libfuturize_fix_names_stage1, libfuturize_fix_names_stage2
fixer_pkg = b'libfuturize.fixes'

def main(args=None):
    parser = optparse.OptionParser(usage=b'futurize [options] file|dir ...')
    parser.add_option(b'-V', b'--version', action=b'store_true', help=b'Report the version number of futurize')
    parser.add_option(b'-a', b'--all-imports', action=b'store_true', help=b'Add all __future__ and future imports to each module')
    parser.add_option(b'-1', b'--stage1', action=b'store_true', help=b'Modernize Python 2 code only; no compatibility with Python 3 (or dependency on ``future``)')
    parser.add_option(b'-2', b'--stage2', action=b'store_true', help=b'Take modernized (stage1) code and add a dependency on ``future`` to provide Py3 compatibility.')
    parser.add_option(b'-0', b'--both-stages', action=b'store_true', help=b'Apply both stages 1 and 2')
    parser.add_option(b'-u', b'--unicode-literals', action=b'store_true', help=b"Add ``from __future__ import unicode_literals`` to implicitly convert all unadorned string literals '' into unicode strings")
    parser.add_option(b'-f', b'--fix', action=b'append', default=[], help=b"Each FIX specifies a transformation; default: all.\nEither use '-f division -f metaclass' etc. or use the fully-qualified module name: '-f lib2to3.fixes.fix_types -f libfuturize.fixes.fix_unicode_keep_u'")
    parser.add_option(b'-j', b'--processes', action=b'store', default=1, type=b'int', help=b'Run 2to3 concurrently')
    parser.add_option(b'-x', b'--nofix', action=b'append', default=[], help=b'Prevent a fixer from being run.')
    parser.add_option(b'-l', b'--list-fixes', action=b'store_true', help=b'List available transformations')
    parser.add_option(b'-p', b'--print-function', action=b'store_true', help=b'Modify the grammar so that print() is a function')
    parser.add_option(b'-v', b'--verbose', action=b'store_true', help=b'More verbose logging')
    parser.add_option(b'--no-diffs', action=b'store_true', help=b"Don't show diffs of the refactoring")
    parser.add_option(b'-w', b'--write', action=b'store_true', help=b'Write back modified files')
    parser.add_option(b'-n', b'--nobackups', action=b'store_true', default=False, help=b"Don't write backups for modified files.")
    parser.add_option(b'-o', b'--output-dir', action=b'store', type=b'str', default=b'', help=b'Put output files in this directory instead of overwriting the input files.  Requires -n. For Python >= 2.7 only.')
    parser.add_option(b'-W', b'--write-unchanged-files', action=b'store_true', help=b'Also write files even if no changes were required (useful with --output-dir); implies -w.')
    parser.add_option(b'--add-suffix', action=b'store', type=b'str', default=b'', help=b"Append this string to all output filenames. Requires -n if non-empty. For Python >= 2.7 only.ex: --add-suffix='3' will generate .py3 files.")
    flags = {}
    refactor_stdin = False
    options, args = parser.parse_args(args)
    if options.write_unchanged_files:
        flags[b'write_unchanged_files'] = True
        if not options.write:
            warn(b'--write-unchanged-files/-W implies -w.')
        options.write = True
    if options.output_dir and not options.nobackups:
        parser.error(b"Can't use --output-dir/-o without -n.")
    if options.add_suffix and not options.nobackups:
        parser.error(b"Can't use --add-suffix without -n.")
    if not options.write and options.no_diffs:
        warn(b"not writing files and not printing diffs; that's not very useful")
    if not options.write and options.nobackups:
        parser.error(b"Can't use -n without -w")
    if b'-' in args:
        refactor_stdin = True
        if options.write:
            print(b"Can't write to stdin.", file=sys.stderr)
            return 2
    if options.print_function:
        flags[b'print_function'] = True
    level = logging.DEBUG if options.verbose else logging.INFO
    logging.basicConfig(format=b'%(name)s: %(message)s', level=level)
    logger = logging.getLogger(b'libfuturize.main')
    if options.stage1 or options.stage2:
        options.both_stages = False
    else:
        options.both_stages = True
    avail_fixes = set()
    if options.stage1 or options.both_stages:
        avail_fixes.update(lib2to3_fix_names_stage1)
        avail_fixes.update(libfuturize_fix_names_stage1)
    if options.stage2 or options.both_stages:
        avail_fixes.update(lib2to3_fix_names_stage2)
        avail_fixes.update(libfuturize_fix_names_stage2)
    if options.unicode_literals:
        avail_fixes.add(b'libfuturize.fixes.fix_unicode_literals_import')
    if options.version:
        print(__version__)
        return 0
    else:
        if options.list_fixes:
            print(b'Available transformations for the -f/--fix option:')
            for fixname in sorted(avail_fixes):
                print(fixname)

            if not args:
                return 0
        if not args:
            print(b'At least one file or directory argument required.', file=sys.stderr)
            print(b'Use --help to show usage.', file=sys.stderr)
            return 2
        unwanted_fixes = set()
        for fix in options.nofix:
            if b'.fix_' in fix:
                unwanted_fixes.add(fix)
            else:
                found = [ f for f in avail_fixes if f.endswith((b'fix_{0}').format(fix))
                        ]
                if len(found) > 1:
                    print(b'Ambiguous fixer name. Choose a fully qualified module name instead from these:\n' + (b'\n').join(b'  ' + myf for myf in found), file=sys.stderr)
                    return 2
                if len(found) == 0:
                    print(b'Unknown fixer. Use --list-fixes or -l for a list.', file=sys.stderr)
                    return 2
                unwanted_fixes.add(found[0])

        extra_fixes = set()
        if options.all_imports:
            if options.stage1:
                prefix = b'libfuturize.fixes.'
                extra_fixes.add(prefix + b'fix_add__future__imports_except_unicode_literals')
            else:
                prefix = b'libpasteurize.fixes.'
                extra_fixes.add(prefix + b'fix_add_all__future__imports')
                extra_fixes.add(prefix + b'fix_add_future_standard_library_import')
                extra_fixes.add(prefix + b'fix_add_all_future_builtins')
        explicit = set()
        if options.fix:
            all_present = False
            for fix in options.fix:
                if fix == b'all':
                    all_present = True
                elif b'.fix_' in fix:
                    explicit.add(fix)
                else:
                    found = [ f for f in avail_fixes if f.endswith((b'fix_{0}').format(fix))
                            ]
                    if len(found) > 1:
                        print(b'Ambiguous fixer name. Choose a fully qualified module name instead from these:\n' + (b'\n').join(b'  ' + myf for myf in found), file=sys.stderr)
                        return 2
                    if len(found) == 0:
                        print(b'Unknown fixer. Use --list-fixes or -l for a list.', file=sys.stderr)
                        return 2
                    explicit.add(found[0])

            if len(explicit & unwanted_fixes) > 0:
                print(b'Conflicting usage: the following fixers have been simultaneously requested and disallowed:\n' + (b'\n').join(b'  ' + myf for myf in explicit & unwanted_fixes), file=sys.stderr)
                return 2
            requested = avail_fixes.union(explicit) if all_present else explicit
        else:
            requested = avail_fixes.union(explicit)
        fixer_names = (requested | extra_fixes) - unwanted_fixes
        input_base_dir = os.path.commonprefix(args)
        if input_base_dir and not input_base_dir.endswith(os.sep) and not os.path.isdir(input_base_dir):
            input_base_dir = os.path.dirname(input_base_dir)
        if options.output_dir:
            input_base_dir = input_base_dir.rstrip(os.sep)
            logger.info(b'Output in %r will mirror the input directory %r layout.', options.output_dir, input_base_dir)
        if future.utils.PY26:
            extra_kwargs = {}
        else:
            extra_kwargs = {b'append_suffix': options.add_suffix, 
               b'output_dir': options.output_dir, 
               b'input_base_dir': input_base_dir}
        rt = StdoutRefactoringTool(sorted(fixer_names), flags, sorted(explicit), options.nobackups, (not options.no_diffs), **extra_kwargs)
        if not rt.errors:
            if refactor_stdin:
                rt.refactor_stdin()
            else:
                try:
                    rt.refactor(args, options.write, None, options.processes)
                except refactor.MultiprocessingUnsupported:
                    print(b"Sorry, -j isn't supported on this platform.", file=sys.stderr)
                    return 1

            rt.summarize()
        return int(bool(rt.errors))