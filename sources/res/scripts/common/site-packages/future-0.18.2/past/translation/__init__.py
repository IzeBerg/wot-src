import imp, logging, marshal, os, sys, copy
from lib2to3.pgen2.parse import ParseError
from lib2to3.refactor import RefactoringTool
from libfuturize import fixes
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
myfixes = list(fixes.libfuturize_fix_names_stage1) + list(fixes.lib2to3_fix_names_stage1) + list(fixes.libfuturize_fix_names_stage2) + list(fixes.lib2to3_fix_names_stage2)
py2_detect_fixers = [
 'lib2to3.fixes.fix_apply',
 'lib2to3.fixes.fix_except',
 'lib2to3.fixes.fix_execfile',
 'lib2to3.fixes.fix_exitfunc',
 'lib2to3.fixes.fix_funcattrs',
 'lib2to3.fixes.fix_filter',
 'lib2to3.fixes.fix_has_key',
 'lib2to3.fixes.fix_idioms',
 'lib2to3.fixes.fix_import',
 'lib2to3.fixes.fix_intern',
 'lib2to3.fixes.fix_isinstance',
 'lib2to3.fixes.fix_methodattrs',
 'lib2to3.fixes.fix_ne',
 'lib2to3.fixes.fix_numliterals',
 'lib2to3.fixes.fix_paren',
 'lib2to3.fixes.fix_print',
 'lib2to3.fixes.fix_raise',
 'lib2to3.fixes.fix_renames',
 'lib2to3.fixes.fix_reduce',
 'lib2to3.fixes.fix_repr',
 'lib2to3.fixes.fix_standarderror',
 'lib2to3.fixes.fix_sys_exc',
 'lib2to3.fixes.fix_throw',
 'lib2to3.fixes.fix_tuple_params',
 'lib2to3.fixes.fix_types',
 'lib2to3.fixes.fix_ws_comma',
 'lib2to3.fixes.fix_xreadlines',
 'lib2to3.fixes.fix_basestring',
 'lib2to3.fixes.fix_exec',
 'lib2to3.fixes.fix_getcwdu',
 'lib2to3.fixes.fix_long',
 'lib2to3.fixes.fix_next',
 'lib2to3.fixes.fix_nonzero',
 'lib2to3.fixes.fix_raw_input',
 'lib2to3.fixes.fix_xrange']

class RTs:
    _rt = None
    _rtp = None
    _rt_py2_detect = None
    _rtp_py2_detect = None

    @staticmethod
    def setup():
        if None in [RTs._rt, RTs._rtp]:
            RTs._rt = RefactoringTool(myfixes)
            RTs._rtp = RefactoringTool(myfixes, {'print_function': True})
        return

    @staticmethod
    def setup_detect_python2():
        if None in [RTs._rt_py2_detect, RTs._rtp_py2_detect]:
            RTs._rt_py2_detect = RefactoringTool(py2_detect_fixers)
            RTs._rtp_py2_detect = RefactoringTool(py2_detect_fixers, {'print_function': True})
        return


def splitall(path):
    allparts = []
    while True:
        parts = os.path.split(path)
        if parts[0] == path:
            allparts.insert(0, parts[0])
            break
        elif parts[1] == path:
            allparts.insert(0, parts[1])
            break
        else:
            path = parts[0]
            allparts.insert(0, parts[1])

    return allparts


def common_substring(s1, s2):
    chunks = []
    path1 = splitall(s1)
    path2 = splitall(s2)
    for dir1, dir2 in zip(path1, path2):
        if dir1 != dir2:
            break
        chunks.append(dir1)

    return os.path.join(*chunks)


def detect_python2(source, pathname):
    RTs.setup_detect_python2()
    try:
        tree = RTs._rt_py2_detect.refactor_string(source, pathname)
    except ParseError as e:
        if e.msg != 'bad input' or e.value != '=':
            raise
        tree = RTs._rtp.refactor_string(source, pathname)

    if source != str(tree)[:-1]:
        logger.debug(('Detected Python 2 code: {0}').format(pathname))
        return True
    else:
        logger.debug(('Detected Python 3 code: {0}').format(pathname))
        return False


class Py2Fixer(object):
    PY2FIXER = True

    def __init__(self):
        self.found = None
        self.base_exclude_paths = ['future', 'past']
        self.exclude_paths = copy.copy(self.base_exclude_paths)
        self.include_paths = []
        return

    def include(self, paths):
        self.include_paths += paths

    def exclude(self, paths):
        self.exclude_paths += paths

    def find_module(self, fullname, path=None):
        logger.debug(('Running find_module: {0}...').format(fullname))
        if '.' in fullname:
            parent, child = fullname.rsplit('.', 1)
            if path is None:
                loader = self.find_module(parent, path)
                mod = loader.load_module(parent)
                path = mod.__path__
            fullname = child
        try:
            self.found = imp.find_module(fullname, path)
        except Exception as e:
            logger.debug('Py2Fixer could not find {0}')
            logger.debug(('Exception was: {0})').format(fullname, e))
            return

        self.kind = self.found[(-1)][(-1)]
        if self.kind == imp.PKG_DIRECTORY:
            self.pathname = os.path.join(self.found[1], '__init__.py')
        elif self.kind == imp.PY_SOURCE:
            self.pathname = self.found[1]
        return self

    def transform(self, source):
        RTs.setup()
        source += '\n'
        try:
            tree = RTs._rt.refactor_string(source, self.pathname)
        except ParseError as e:
            if e.msg != 'bad input' or e.value != '=':
                raise
            tree = RTs._rtp.refactor_string(source, self.pathname)

        return str(tree)[:-1]

    def load_module(self, fullname):
        logger.debug(('Running load_module for {0}...').format(fullname))
        if fullname in sys.modules:
            mod = sys.modules[fullname]
        elif self.kind in (imp.PY_COMPILED, imp.C_EXTENSION, imp.C_BUILTIN,
         imp.PY_FROZEN):
            convert = False
        else:
            if any([ fullname.startswith(path) for path in self.exclude_paths ]):
                convert = False
            elif any([ fullname.startswith(path) for path in self.include_paths ]):
                convert = True
            else:
                convert = False
            if not convert:
                logger.debug(('Excluded {0} from translation').format(fullname))
                mod = imp.load_module(fullname, *self.found)
            else:
                logger.debug(('Autoconverting {0} ...').format(fullname))
                mod = imp.new_module(fullname)
                sys.modules[fullname] = mod
                mod.__file__ = self.pathname
                mod.__name__ = fullname
                mod.__loader__ = self
                if self.kind == imp.PKG_DIRECTORY:
                    mod.__path__ = [
                     os.path.dirname(self.pathname)]
                    mod.__package__ = fullname
                else:
                    mod.__path__ = []
                    mod.__package__ = fullname.rpartition('.')[0]
                try:
                    cachename = imp.cache_from_source(self.pathname)
                    if not os.path.exists(cachename):
                        update_cache = True
                    else:
                        sourcetime = os.stat(self.pathname).st_mtime
                        cachetime = os.stat(cachename).st_mtime
                        update_cache = cachetime < sourcetime
                    if not update_cache:
                        with open(cachename, 'rb') as (f):
                            data = f.read()
                            try:
                                code = marshal.loads(data)
                            except Exception:
                                update_cache = True

                    if update_cache:
                        if self.found[0]:
                            source = self.found[0].read()
                        else:
                            if self.kind == imp.PKG_DIRECTORY:
                                with open(self.pathname) as (f):
                                    source = f.read()
                            if detect_python2(source, self.pathname):
                                source = self.transform(source)
                            code = compile(source, self.pathname, 'exec')
                            dirname = os.path.dirname(cachename)
                            try:
                                if not os.path.exists(dirname):
                                    os.makedirs(dirname)
                                with open(cachename, 'wb') as (f):
                                    data = marshal.dumps(code)
                                    f.write(data)
                            except Exception:
                                pass

                    exec code in mod.__dict__
                except Exception as e:
                    del sys.modules[fullname]
                    raise

        if self.found[0]:
            self.found[0].close()
        return mod


_hook = Py2Fixer()

def install_hooks(include_paths=(), exclude_paths=()):
    if isinstance(include_paths, str):
        include_paths = (
         include_paths,)
    if isinstance(exclude_paths, str):
        exclude_paths = (
         exclude_paths,)
    _hook.include(include_paths)
    _hook.exclude(exclude_paths)
    enable = sys.version_info[0] >= 3
    if enable and _hook not in sys.meta_path:
        sys.meta_path.insert(0, _hook)


def remove_hooks():
    if _hook in sys.meta_path:
        sys.meta_path.remove(_hook)


def detect_hooks():
    return _hook in sys.meta_path


class hooks(object):

    def __enter__(self):
        self.hooks_were_installed = detect_hooks()
        install_hooks()
        return self

    def __exit__(self, *args):
        if not self.hooks_were_installed:
            remove_hooks()


class suspend_hooks(object):

    def __enter__(self):
        self.hooks_were_installed = detect_hooks()
        remove_hooks()
        return self

    def __exit__(self, *args):
        if self.hooks_were_installed:
            install_hooks()


autotranslate = install_hooks