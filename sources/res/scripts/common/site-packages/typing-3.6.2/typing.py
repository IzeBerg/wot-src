from __future__ import absolute_import, unicode_literals
import abc
from abc import abstractmethod, abstractproperty
import collections, functools, re as stdlib_re, sys, types
try:
    import collections.abc as collections_abc
except ImportError:
    import collections as collections_abc

__all__ = [
 b'Any',
 b'Callable',
 b'ClassVar',
 b'Generic',
 b'Optional',
 b'Tuple',
 b'Type',
 b'TypeVar',
 b'Union',
 b'AbstractSet',
 b'GenericMeta',
 b'ByteString',
 b'Container',
 b'ContextManager',
 b'Hashable',
 b'ItemsView',
 b'Iterable',
 b'Iterator',
 b'KeysView',
 b'Mapping',
 b'MappingView',
 b'MutableMapping',
 b'MutableSequence',
 b'MutableSet',
 b'Sequence',
 b'Sized',
 b'ValuesView',
 b'Reversible',
 b'SupportsAbs',
 b'SupportsComplex',
 b'SupportsFloat',
 b'SupportsInt',
 b'Counter',
 b'Deque',
 b'Dict',
 b'DefaultDict',
 b'List',
 b'Set',
 b'FrozenSet',
 b'NamedTuple',
 b'Generator',
 b'AnyStr',
 b'cast',
 b'get_type_hints',
 b'NewType',
 b'no_type_check',
 b'no_type_check_decorator',
 b'overload',
 b'Text',
 b'TYPE_CHECKING']

def _qualname(x):
    if sys.version_info[:2] >= (3, 3):
        return x.__qualname__
    else:
        return x.__name__


def _trim_name(nm):
    whitelist = ('_TypeAlias', '_ForwardRef', '_TypingBase', '_FinalTypingBase')
    if nm.startswith(b'_') and nm not in whitelist:
        nm = nm[1:]
    return nm


class TypingMeta(type):
    _is_protocol = False

    def __new__(cls, name, bases, namespace):
        return super(TypingMeta, cls).__new__(cls, str(name), bases, namespace)

    @classmethod
    def assert_no_subclassing(cls, bases):
        for base in bases:
            if isinstance(base, cls):
                raise TypeError(b'Cannot subclass %s' % ((b', ').join(map(_type_repr, bases)) or b'()'))

    def __init__(self, *args, **kwds):
        pass

    def _eval_type(self, globalns, localns):
        return self

    def _get_type_vars(self, tvars):
        pass

    def __repr__(self):
        qname = _trim_name(_qualname(self))
        return b'%s.%s' % (self.__module__, qname)


class _TypingBase(object):
    __metaclass__ = TypingMeta
    __slots__ = ('__weakref__', )

    def __init__(self, *args, **kwds):
        pass

    def __new__(cls, *args, **kwds):
        if len(args) == 3 and isinstance(args[0], str) and isinstance(args[1], tuple):
            raise TypeError(b'Cannot subclass %r' % cls)
        return super(_TypingBase, cls).__new__(cls)

    def _eval_type(self, globalns, localns):
        return self

    def _get_type_vars(self, tvars):
        pass

    def __repr__(self):
        cls = type(self)
        qname = _trim_name(_qualname(cls))
        return b'%s.%s' % (cls.__module__, qname)

    def __call__(self, *args, **kwds):
        raise TypeError(b'Cannot instantiate %r' % type(self))


class _FinalTypingBase(_TypingBase):
    __slots__ = ()

    def __new__(cls, *args, **kwds):
        self = super(_FinalTypingBase, cls).__new__(cls, *args, **kwds)
        if b'_root' in kwds and kwds[b'_root'] is True:
            return self
        raise TypeError(b'Cannot instantiate %r' % cls)

    def __reduce__(self):
        return _trim_name(type(self).__name__)


class _ForwardRef(_TypingBase):
    __slots__ = ('__forward_arg__', '__forward_code__', '__forward_evaluated__', '__forward_value__')

    def __init__(self, arg):
        super(_ForwardRef, self).__init__(arg)
        if not isinstance(arg, basestring):
            raise TypeError(b'Forward reference must be a string -- got %r' % (arg,))
        try:
            code = compile(arg, b'<string>', b'eval')
        except SyntaxError:
            raise SyntaxError(b'Forward reference must be an expression -- got %r' % (
             arg,))

        self.__forward_arg__ = arg
        self.__forward_code__ = code
        self.__forward_evaluated__ = False
        self.__forward_value__ = None
        return

    def _eval_type(self, globalns, localns):
        if not self.__forward_evaluated__ or localns is not globalns:
            if globalns is None and localns is None:
                globalns = localns = {}
            elif globalns is None:
                globalns = localns
            elif localns is None:
                localns = globalns
            self.__forward_value__ = _type_check(eval(self.__forward_code__, globalns, localns), b'Forward references must evaluate to types.')
            self.__forward_evaluated__ = True
        return self.__forward_value__

    def __eq__(self, other):
        if not isinstance(other, _ForwardRef):
            return NotImplemented
        return self.__forward_arg__ == other.__forward_arg__ and self.__forward_value__ == other.__forward_value__

    def __hash__(self):
        return hash((self.__forward_arg__, self.__forward_value__))

    def __instancecheck__(self, obj):
        raise TypeError(b'Forward references cannot be used with isinstance().')

    def __subclasscheck__(self, cls):
        raise TypeError(b'Forward references cannot be used with issubclass().')

    def __repr__(self):
        return b'_ForwardRef(%r)' % (self.__forward_arg__,)


class _TypeAlias(_TypingBase):
    __slots__ = ('name', 'type_var', 'impl_type', 'type_checker')

    def __init__(self, name, type_var, impl_type, type_checker):
        self.name = name
        self.type_var = type_var
        self.impl_type = impl_type
        self.type_checker = type_checker

    def __repr__(self):
        return b'%s[%s]' % (self.name, _type_repr(self.type_var))

    def __getitem__(self, parameter):
        if not isinstance(self.type_var, TypeVar):
            raise TypeError(b'%s cannot be further parameterized.' % self)
        if self.type_var.__constraints__ and isinstance(parameter, type):
            if not issubclass(parameter, self.type_var.__constraints__):
                raise TypeError(b'%s is not a valid substitution for %s.' % (
                 parameter, self.type_var))
        if isinstance(parameter, TypeVar) and parameter is not self.type_var:
            raise TypeError(b'%s cannot be re-parameterized.' % self)
        return self.__class__(self.name, parameter, self.impl_type, self.type_checker)

    def __eq__(self, other):
        if not isinstance(other, _TypeAlias):
            return NotImplemented
        return self.name == other.name and self.type_var == other.type_var

    def __hash__(self):
        return hash((self.name, self.type_var))

    def __instancecheck__(self, obj):
        if not isinstance(self.type_var, TypeVar):
            raise TypeError(b'Parameterized type aliases cannot be used with isinstance().')
        return isinstance(obj, self.impl_type)

    def __subclasscheck__(self, cls):
        if not isinstance(self.type_var, TypeVar):
            raise TypeError(b'Parameterized type aliases cannot be used with issubclass().')
        return issubclass(cls, self.impl_type)


def _get_type_vars(types, tvars):
    for t in types:
        if isinstance(t, TypingMeta) or isinstance(t, _TypingBase):
            t._get_type_vars(tvars)


def _type_vars(types):
    tvars = []
    _get_type_vars(types, tvars)
    return tuple(tvars)


def _eval_type(t, globalns, localns):
    if isinstance(t, TypingMeta) or isinstance(t, _TypingBase):
        return t._eval_type(globalns, localns)
    return t


def _type_check(arg, msg):
    if arg is None:
        return type(None)
    else:
        if isinstance(arg, basestring):
            arg = _ForwardRef(arg)
        if isinstance(arg, _TypingBase) and type(arg).__name__ == b'_ClassVar' or not isinstance(arg, (type, _TypingBase)) and not callable(arg):
            raise TypeError(msg + b' Got %.100r.' % (arg,))
        if type(arg).__name__ in ('_Union', '_Optional') and not getattr(arg, b'__origin__', None) or isinstance(arg, TypingMeta) and _gorg(arg) in (Generic, _Protocol):
            raise TypeError(b'Plain %s is not valid as type argument' % arg)
        return arg


def _type_repr(obj):
    if isinstance(obj, type) and not isinstance(obj, TypingMeta):
        if obj.__module__ == b'__builtin__':
            return _qualname(obj)
        return b'%s.%s' % (obj.__module__, _qualname(obj))
    if obj is Ellipsis:
        return b'...'
    if isinstance(obj, types.FunctionType):
        return obj.__name__
    return repr(obj)


class ClassVarMeta(TypingMeta):

    def __new__(cls, name, bases, namespace):
        cls.assert_no_subclassing(bases)
        self = super(ClassVarMeta, cls).__new__(cls, name, bases, namespace)
        return self


class _ClassVar(_FinalTypingBase):
    __metaclass__ = ClassVarMeta
    __slots__ = ('__type__', )

    def __init__(self, tp=None, _root=False):
        self.__type__ = tp

    def __getitem__(self, item):
        cls = type(self)
        if self.__type__ is None:
            return cls(_type_check(item, (b'{} accepts only types.').format(cls.__name__[1:])), _root=True)
        else:
            raise TypeError((b'{} cannot be further subscripted').format(cls.__name__[1:]))
            return

    def _eval_type(self, globalns, localns):
        return type(self)(_eval_type(self.__type__, globalns, localns), _root=True)

    def __repr__(self):
        r = super(_ClassVar, self).__repr__()
        if self.__type__ is not None:
            r += (b'[{}]').format(_type_repr(self.__type__))
        return r

    def __hash__(self):
        return hash((type(self).__name__, self.__type__))

    def __eq__(self, other):
        if not isinstance(other, _ClassVar):
            return NotImplemented
        else:
            if self.__type__ is not None:
                return self.__type__ == other.__type__
            return self is other


ClassVar = _ClassVar(_root=True)

class AnyMeta(TypingMeta):

    def __new__(cls, name, bases, namespace):
        cls.assert_no_subclassing(bases)
        self = super(AnyMeta, cls).__new__(cls, name, bases, namespace)
        return self


class _Any(_FinalTypingBase):
    __metaclass__ = AnyMeta
    __slots__ = ()

    def __instancecheck__(self, obj):
        raise TypeError(b'Any cannot be used with isinstance().')

    def __subclasscheck__(self, cls):
        raise TypeError(b'Any cannot be used with issubclass().')


Any = _Any(_root=True)

class NoReturnMeta(TypingMeta):

    def __new__(cls, name, bases, namespace):
        cls.assert_no_subclassing(bases)
        self = super(NoReturnMeta, cls).__new__(cls, name, bases, namespace)
        return self


class _NoReturn(_FinalTypingBase):
    __metaclass__ = NoReturnMeta
    __slots__ = ()

    def __instancecheck__(self, obj):
        raise TypeError(b'NoReturn cannot be used with isinstance().')

    def __subclasscheck__(self, cls):
        raise TypeError(b'NoReturn cannot be used with issubclass().')


NoReturn = _NoReturn(_root=True)

class TypeVarMeta(TypingMeta):

    def __new__(cls, name, bases, namespace):
        cls.assert_no_subclassing(bases)
        return super(TypeVarMeta, cls).__new__(cls, name, bases, namespace)


class TypeVar(_TypingBase):
    __metaclass__ = TypeVarMeta
    __slots__ = ('__name__', '__bound__', '__constraints__', '__covariant__', '__contravariant__')

    def __init__(self, name, *constraints, **kwargs):
        super(TypeVar, self).__init__(name, *constraints, **kwargs)
        bound = kwargs.get(b'bound', None)
        covariant = kwargs.get(b'covariant', False)
        contravariant = kwargs.get(b'contravariant', False)
        self.__name__ = name
        if covariant and contravariant:
            raise ValueError(b'Bivariant types are not supported.')
        self.__covariant__ = bool(covariant)
        self.__contravariant__ = bool(contravariant)
        if constraints and bound is not None:
            raise TypeError(b'Constraints cannot be combined with bound=...')
        if constraints and len(constraints) == 1:
            raise TypeError(b'A single constraint is not allowed')
        msg = b'TypeVar(name, constraint, ...): constraints must be types.'
        self.__constraints__ = tuple(_type_check(t, msg) for t in constraints)
        if bound:
            self.__bound__ = _type_check(bound, b'Bound must be a type.')
        else:
            self.__bound__ = None
        return

    def _get_type_vars(self, tvars):
        if self not in tvars:
            tvars.append(self)

    def __repr__(self):
        if self.__covariant__:
            prefix = b'+'
        elif self.__contravariant__:
            prefix = b'-'
        else:
            prefix = b'~'
        return prefix + self.__name__

    def __instancecheck__(self, instance):
        raise TypeError(b'Type variables cannot be used with isinstance().')

    def __subclasscheck__(self, cls):
        raise TypeError(b'Type variables cannot be used with issubclass().')


T = TypeVar(b'T')
KT = TypeVar(b'KT')
VT = TypeVar(b'VT')
T_co = TypeVar(b'T_co', covariant=True)
V_co = TypeVar(b'V_co', covariant=True)
VT_co = TypeVar(b'VT_co', covariant=True)
T_contra = TypeVar(b'T_contra', contravariant=True)
AnyStr = TypeVar(b'AnyStr', bytes, unicode)

def _replace_arg(arg, tvars, args):
    if tvars is None:
        tvars = []
    if hasattr(arg, b'_subs_tree') and isinstance(arg, (GenericMeta, _TypingBase)):
        return arg._subs_tree(tvars, args)
    else:
        if isinstance(arg, TypeVar):
            for i, tvar in enumerate(tvars):
                if arg == tvar:
                    return args[i]

        return arg


def _subs_tree(cls, tvars=None, args=None):
    if cls.__origin__ is None:
        return cls
    else:
        current = cls.__origin__
        orig_chain = []
        while current.__origin__ is not None:
            orig_chain.append(current)
            current = current.__origin__

        tree_args = []
        for arg in cls.__args__:
            tree_args.append(_replace_arg(arg, tvars, args))

        for ocls in orig_chain:
            new_tree_args = []
            for arg in ocls.__args__:
                new_tree_args.append(_replace_arg(arg, ocls.__parameters__, tree_args))

            tree_args = new_tree_args

        return tree_args


def _remove_dups_flatten(parameters):
    params = []
    for p in parameters:
        if isinstance(p, _Union) and p.__origin__ is Union:
            params.extend(p.__args__)
        elif isinstance(p, tuple) and len(p) > 0 and p[0] is Union:
            params.extend(p[1:])
        else:
            params.append(p)

    all_params = set(params)
    if len(all_params) < len(params):
        new_params = []
        for t in params:
            if t in all_params:
                new_params.append(t)
                all_params.remove(t)

        params = new_params
    all_params = set(params)
    for t1 in params:
        if not isinstance(t1, type):
            continue
        if any(isinstance(t2, type) and issubclass(t1, t2) for t2 in all_params - {t1} if not (isinstance(t2, GenericMeta) and t2.__origin__ is not None)):
            all_params.remove(t1)

    return tuple(t for t in params if t in all_params)


def _check_generic(cls, parameters):
    if not cls.__parameters__:
        raise TypeError(b'%s is not a generic class' % repr(cls))
    alen = len(parameters)
    elen = len(cls.__parameters__)
    if alen != elen:
        raise TypeError(b'Too %s parameters for %s; actual %s, expected %s' % (
         b'many' if alen > elen else b'few', repr(cls), alen, elen))


_cleanups = []

def _tp_cache(func):
    maxsize = 128
    cache = {}
    _cleanups.append(cache.clear)

    @functools.wraps(func)
    def inner(*args):
        key = args
        try:
            return cache[key]
        except TypeError:
            return func(*args)
        except KeyError:
            value = func(*args)
            if len(cache) >= maxsize:
                cache.clear()
            cache[key] = value
            return value

    return inner


class UnionMeta(TypingMeta):

    def __new__(cls, name, bases, namespace):
        cls.assert_no_subclassing(bases)
        return super(UnionMeta, cls).__new__(cls, name, bases, namespace)


class _Union(_FinalTypingBase):
    __metaclass__ = UnionMeta
    __slots__ = ('__parameters__', '__args__', '__origin__', '__tree_hash__')

    def __new__(cls, parameters=None, origin=None, *args, **kwds):
        self = super(_Union, cls).__new__(cls, parameters, origin, *args, **kwds)
        if origin is None:
            self.__parameters__ = None
            self.__args__ = None
            self.__origin__ = None
            self.__tree_hash__ = hash(frozenset(('Union', )))
            return self
        else:
            if not isinstance(parameters, tuple):
                raise TypeError(b'Expected parameters=<tuple>')
            if origin is Union:
                parameters = _remove_dups_flatten(parameters)
                if len(parameters) == 1:
                    return parameters[0]
            self.__parameters__ = _type_vars(parameters)
            self.__args__ = parameters
            self.__origin__ = origin
            subs_tree = self._subs_tree()
            if isinstance(subs_tree, tuple):
                self.__tree_hash__ = hash(frozenset(subs_tree))
            else:
                self.__tree_hash__ = hash(subs_tree)
            return self

    def _eval_type(self, globalns, localns):
        if self.__args__ is None:
            return self
        else:
            ev_args = tuple(_eval_type(t, globalns, localns) for t in self.__args__)
            ev_origin = _eval_type(self.__origin__, globalns, localns)
            if ev_args == self.__args__ and ev_origin == self.__origin__:
                return self
            return self.__class__(ev_args, ev_origin, _root=True)

    def _get_type_vars(self, tvars):
        if self.__origin__ and self.__parameters__:
            _get_type_vars(self.__parameters__, tvars)

    def __repr__(self):
        if self.__origin__ is None:
            return super(_Union, self).__repr__()
        else:
            tree = self._subs_tree()
            if not isinstance(tree, tuple):
                return repr(tree)
            return tree[0]._tree_repr(tree)

    def _tree_repr(self, tree):
        arg_list = []
        for arg in tree[1:]:
            if not isinstance(arg, tuple):
                arg_list.append(_type_repr(arg))
            else:
                arg_list.append(arg[0]._tree_repr(arg))

        return super(_Union, self).__repr__() + b'[%s]' % (b', ').join(arg_list)

    @_tp_cache
    def __getitem__(self, parameters):
        if parameters == ():
            raise TypeError(b'Cannot take a Union of no types.')
        if not isinstance(parameters, tuple):
            parameters = (
             parameters,)
        if self.__origin__ is None:
            msg = b'Union[arg, ...]: each arg must be a type.'
        else:
            msg = b'Parameters to generic types must be types.'
        parameters = tuple(_type_check(p, msg) for p in parameters)
        if self is not Union:
            _check_generic(self, parameters)
        return self.__class__(parameters, origin=self, _root=True)

    def _subs_tree(self, tvars=None, args=None):
        if self is Union:
            return Union
        tree_args = _subs_tree(self, tvars, args)
        tree_args = _remove_dups_flatten(tree_args)
        if len(tree_args) == 1:
            return tree_args[0]
        return (
         Union,) + tree_args

    def __eq__(self, other):
        if isinstance(other, _Union):
            return self.__tree_hash__ == other.__tree_hash__
        else:
            if self is not Union:
                return self._subs_tree() == other
            return self is other

    def __hash__(self):
        return self.__tree_hash__

    def __instancecheck__(self, obj):
        raise TypeError(b'Unions cannot be used with isinstance().')

    def __subclasscheck__(self, cls):
        raise TypeError(b'Unions cannot be used with issubclass().')


Union = _Union(_root=True)

class OptionalMeta(TypingMeta):

    def __new__(cls, name, bases, namespace):
        cls.assert_no_subclassing(bases)
        return super(OptionalMeta, cls).__new__(cls, name, bases, namespace)


class _Optional(_FinalTypingBase):
    __metaclass__ = OptionalMeta
    __slots__ = ()

    @_tp_cache
    def __getitem__(self, arg):
        arg = _type_check(arg, b'Optional[t] requires a single type.')
        return Union[(arg, type(None))]


Optional = _Optional(_root=True)

def _gorg(a):
    while a.__origin__ is not None:
        a = a.__origin__

    return a


def _geqv(a, b):
    return _gorg(a) is _gorg(b)


def _next_in_mro(cls):
    next_in_mro = object
    for i, c in enumerate(cls.__mro__[:-1]):
        if isinstance(c, GenericMeta) and _gorg(c) is Generic:
            next_in_mro = cls.__mro__[(i + 1)]

    return next_in_mro


def _make_subclasshook(cls):
    if isinstance(cls.__extra__, abc.ABCMeta):

        def __extrahook__(cls, subclass):
            res = cls.__extra__.__subclasshook__(subclass)
            if res is not NotImplemented:
                return res
            if cls.__extra__ in getattr(subclass, b'__mro__', ()):
                return True
            for scls in cls.__extra__.__subclasses__():
                if isinstance(scls, GenericMeta):
                    continue
                if issubclass(subclass, scls):
                    return True

            return NotImplemented

    else:

        def __extrahook__(cls, subclass):
            if cls.__extra__ and issubclass(subclass, cls.__extra__):
                return True
            return NotImplemented

    return classmethod(__extrahook__)


class GenericMeta(TypingMeta, abc.ABCMeta):

    def __new__(cls, name, bases, namespace, tvars=None, args=None, origin=None, extra=None, orig_bases=None):
        if tvars is not None:
            pass
        else:
            tvars = _type_vars(bases)
            gvars = None
            for base in bases:
                if base is Generic:
                    raise TypeError(b'Cannot inherit from plain Generic')
                if isinstance(base, GenericMeta) and base.__origin__ is Generic:
                    if gvars is not None:
                        raise TypeError(b'Cannot inherit from Generic[...] multiple types.')
                    gvars = base.__parameters__

            if gvars is None:
                gvars = tvars
            else:
                tvarset = set(tvars)
                gvarset = set(gvars)
                if not tvarset <= gvarset:
                    raise TypeError(b'Some type variables (%s) are not listed in Generic[%s]' % (
                     (b', ').join(str(t) for t in tvars if t not in gvarset),
                     (b', ').join(str(g) for g in gvars)))
                tvars = gvars
        initial_bases = bases
        if extra is None:
            extra = namespace.get(b'__extra__')
        if extra is not None and type(extra) is abc.ABCMeta and extra not in bases:
            bases = (
             extra,) + bases
        bases = tuple((_gorg(b) if isinstance(b, GenericMeta) else b) for b in bases)
        if any(isinstance(b, GenericMeta) and b is not Generic for b in bases):
            bases = tuple(b for b in bases if b is not Generic)
        namespace.update({b'__origin__': origin, b'__extra__': extra})
        self = super(GenericMeta, cls).__new__(cls, name, bases, namespace)
        self.__parameters__ = tvars
        self.__args__ = tuple((Ellipsis if a is _TypingEllipsis else () if a is _TypingEmpty else a) for a in args) if args else None
        self.__next_in_mro__ = _next_in_mro(self)
        if orig_bases is None:
            self.__orig_bases__ = initial_bases
        if b'__subclasshook__' not in namespace and extra or getattr(self.__subclasshook__, b'__name__', b'') == b'__extrahook__':
            self.__subclasshook__ = _make_subclasshook(self)
        if origin and hasattr(origin, b'__qualname__'):
            self.__qualname__ = origin.__qualname__
        self.__tree_hash__ = hash(self._subs_tree()) if origin else super(GenericMeta, self).__hash__()
        return self

    def __init__(self, *args, **kwargs):
        super(GenericMeta, self).__init__(*args, **kwargs)
        if isinstance(self.__extra__, abc.ABCMeta):
            self._abc_registry = self.__extra__._abc_registry
            self._abc_cache = self.__extra__._abc_cache
        elif self.__origin__ is not None:
            self._abc_registry = self.__origin__._abc_registry
            self._abc_cache = self.__origin__._abc_cache
        return

    @property
    def _abc_negative_cache(self):
        if isinstance(self.__extra__, abc.ABCMeta):
            return self.__extra__._abc_negative_cache
        return _gorg(self)._abc_generic_negative_cache

    @_abc_negative_cache.setter
    def _abc_negative_cache(self, value):
        if self.__origin__ is None:
            if isinstance(self.__extra__, abc.ABCMeta):
                self.__extra__._abc_negative_cache = value
            else:
                self._abc_generic_negative_cache = value
        return

    @property
    def _abc_negative_cache_version(self):
        if isinstance(self.__extra__, abc.ABCMeta):
            return self.__extra__._abc_negative_cache_version
        return _gorg(self)._abc_generic_negative_cache_version

    @_abc_negative_cache_version.setter
    def _abc_negative_cache_version(self, value):
        if self.__origin__ is None:
            if isinstance(self.__extra__, abc.ABCMeta):
                self.__extra__._abc_negative_cache_version = value
            else:
                self._abc_generic_negative_cache_version = value
        return

    def _get_type_vars(self, tvars):
        if self.__origin__ and self.__parameters__:
            _get_type_vars(self.__parameters__, tvars)

    def _eval_type(self, globalns, localns):
        ev_origin = self.__origin__._eval_type(globalns, localns) if self.__origin__ else None
        ev_args = tuple(_eval_type(a, globalns, localns) for a in self.__args__) if self.__args__ else None
        if ev_origin == self.__origin__ and ev_args == self.__args__:
            return self
        else:
            return self.__class__(self.__name__, self.__bases__, dict(self.__dict__), tvars=_type_vars(ev_args) if ev_args else None, args=ev_args, origin=ev_origin, extra=self.__extra__, orig_bases=self.__orig_bases__)

    def __repr__(self):
        if self.__origin__ is None:
            return super(GenericMeta, self).__repr__()
        else:
            return self._tree_repr(self._subs_tree())

    def _tree_repr(self, tree):
        arg_list = []
        for arg in tree[1:]:
            if arg == ():
                arg_list.append(b'()')
            elif not isinstance(arg, tuple):
                arg_list.append(_type_repr(arg))
            else:
                arg_list.append(arg[0]._tree_repr(arg))

        return super(GenericMeta, self).__repr__() + b'[%s]' % (b', ').join(arg_list)

    def _subs_tree(self, tvars=None, args=None):
        if self.__origin__ is None:
            return self
        else:
            tree_args = _subs_tree(self, tvars, args)
            return (_gorg(self),) + tuple(tree_args)

    def __eq__(self, other):
        if not isinstance(other, GenericMeta):
            return NotImplemented
        else:
            if self.__origin__ is None or other.__origin__ is None:
                return self is other
            return self.__tree_hash__ == other.__tree_hash__

    def __hash__(self):
        return self.__tree_hash__

    @_tp_cache
    def __getitem__(self, params):
        if not isinstance(params, tuple):
            params = (
             params,)
        if not params and _gorg(self) is not Tuple:
            raise TypeError(b'Parameter list to %s[...] cannot be empty' % _qualname(self))
        msg = b'Parameters to generic types must be types.'
        params = tuple(_type_check(p, msg) for p in params)
        if self is Generic:
            if not all(isinstance(p, TypeVar) for p in params):
                raise TypeError(b'Parameters to Generic[...] must all be type variables')
            if len(set(params)) != len(params):
                raise TypeError(b'Parameters to Generic[...] must all be unique')
            tvars = params
            args = params
        elif self in (Tuple, Callable):
            tvars = _type_vars(params)
            args = params
        elif self is _Protocol:
            tvars = params
            args = params
        elif self.__origin__ in (Generic, _Protocol):
            raise TypeError(b'Cannot subscript already-subscripted %s' % repr(self))
        else:
            _check_generic(self, params)
            tvars = _type_vars(params)
            args = params
        prepend = (self,) if self.__origin__ is None else ()
        return self.__class__(self.__name__, prepend + self.__bases__, dict(self.__dict__), tvars=tvars, args=args, origin=self, extra=self.__extra__, orig_bases=self.__orig_bases__)

    def __subclasscheck__(self, cls):
        if self.__origin__ is not None:
            if sys._getframe(1).f_globals[b'__name__'] not in ('abc', 'functools'):
                raise TypeError(b'Parameterized generics cannot be used with class or instance checks')
            return False
        if self is Generic:
            raise TypeError(b'Class %r cannot be used with class or instance checks' % self)
        return super(GenericMeta, self).__subclasscheck__(cls)

    def __instancecheck__(self, instance):
        if not isinstance(instance, type):
            return issubclass(instance.__class__, self)
        return False

    def __copy__(self):
        return self.__class__(self.__name__, self.__bases__, dict(self.__dict__), self.__parameters__, self.__args__, self.__origin__, self.__extra__, self.__orig_bases__)

    def __setattr__(self, attr, value):
        if attr.startswith(b'__') and attr.endswith(b'__') or attr.startswith(b'_abc_'):
            super(GenericMeta, self).__setattr__(attr, value)
        else:
            super(GenericMeta, _gorg(self)).__setattr__(attr, value)


Generic = None

def _generic_new(base_cls, cls, *args, **kwds):
    if cls.__origin__ is None:
        return base_cls.__new__(cls)
    else:
        origin = _gorg(cls)
        obj = base_cls.__new__(origin)
        try:
            obj.__orig_class__ = cls
        except AttributeError:
            pass

        obj.__init__(*args, **kwds)
        return obj
        return


class Generic(object):
    __metaclass__ = GenericMeta
    __slots__ = ()

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Generic):
            raise TypeError(b'Type Generic cannot be instantiated; it can be used only as a base class')
        return _generic_new(cls.__next_in_mro__, cls, *args, **kwds)


class _TypingEmpty(object):
    pass


class _TypingEllipsis(object):
    pass


class TupleMeta(GenericMeta):

    @_tp_cache
    def __getitem__(self, parameters):
        if self.__origin__ is not None or not _geqv(self, Tuple):
            return super(TupleMeta, self).__getitem__(parameters)
        else:
            if parameters == ():
                return super(TupleMeta, self).__getitem__((_TypingEmpty,))
            if not isinstance(parameters, tuple):
                parameters = (
                 parameters,)
            if len(parameters) == 2 and parameters[1] is Ellipsis:
                msg = b'Tuple[t, ...]: t must be a type.'
                p = _type_check(parameters[0], msg)
                return super(TupleMeta, self).__getitem__((p, _TypingEllipsis))
            msg = b'Tuple[t0, t1, ...]: each t must be a type.'
            parameters = tuple(_type_check(p, msg) for p in parameters)
            return super(TupleMeta, self).__getitem__(parameters)

    def __instancecheck__(self, obj):
        if self.__args__ is None:
            return isinstance(obj, tuple)
        else:
            raise TypeError(b'Parameterized Tuple cannot be used with isinstance().')
            return

    def __subclasscheck__(self, cls):
        if self.__args__ is None:
            return issubclass(cls, tuple)
        else:
            raise TypeError(b'Parameterized Tuple cannot be used with issubclass().')
            return


class Tuple(tuple):
    __metaclass__ = TupleMeta
    __extra__ = tuple
    __slots__ = ()

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Tuple):
            raise TypeError(b'Type Tuple cannot be instantiated; use tuple() instead')
        return _generic_new(tuple, cls, *args, **kwds)


class CallableMeta(GenericMeta):

    def __repr__(self):
        if self.__origin__ is None:
            return super(CallableMeta, self).__repr__()
        else:
            return self._tree_repr(self._subs_tree())

    def _tree_repr(self, tree):
        if _gorg(self) is not Callable:
            return super(CallableMeta, self)._tree_repr(tree)
        arg_list = []
        for arg in tree[1:]:
            if not isinstance(arg, tuple):
                arg_list.append(_type_repr(arg))
            else:
                arg_list.append(arg[0]._tree_repr(arg))

        if arg_list[0] == b'...':
            return repr(tree[0]) + b'[..., %s]' % arg_list[1]
        return repr(tree[0]) + b'[[%s], %s]' % ((b', ').join(arg_list[:-1]), arg_list[(-1)])

    def __getitem__(self, parameters):
        if self.__origin__ is not None or not _geqv(self, Callable):
            return super(CallableMeta, self).__getitem__(parameters)
        else:
            if not isinstance(parameters, tuple) or len(parameters) != 2:
                raise TypeError(b'Callable must be used as Callable[[arg, ...], result].')
            args, result = parameters
            if args is Ellipsis:
                parameters = (
                 Ellipsis, result)
            else:
                if not isinstance(args, list):
                    raise TypeError(b'Callable[args, result]: args must be a list. Got %.100r.' % (
                     args,))
                parameters = (
                 tuple(args), result)
            return self.__getitem_inner__(parameters)

    @_tp_cache
    def __getitem_inner__(self, parameters):
        args, result = parameters
        msg = b'Callable[args, result]: result must be a type.'
        result = _type_check(result, msg)
        if args is Ellipsis:
            return super(CallableMeta, self).__getitem__((_TypingEllipsis, result))
        msg = b'Callable[[arg, ...], result]: each arg must be a type.'
        args = tuple(_type_check(arg, msg) for arg in args)
        parameters = args + (result,)
        return super(CallableMeta, self).__getitem__(parameters)


class Callable(object):
    __metaclass__ = CallableMeta
    __extra__ = collections_abc.Callable
    __slots__ = ()

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Callable):
            raise TypeError(b'Type Callable cannot be instantiated; use a non-abstract subclass instead')
        return _generic_new(cls.__next_in_mro__, cls, *args, **kwds)


def cast(typ, val):
    return val


def _get_defaults(func):
    code = func.__code__
    pos_count = code.co_argcount
    arg_names = code.co_varnames
    arg_names = arg_names[:pos_count]
    defaults = func.__defaults__ or ()
    kwdefaults = func.__kwdefaults__
    res = dict(kwdefaults) if kwdefaults else {}
    pos_offset = pos_count - len(defaults)
    for name, value in zip(arg_names[pos_offset:], defaults):
        res[name] = value

    return res


def get_type_hints(obj, globalns=None, localns=None):
    return


def no_type_check(arg):
    if isinstance(arg, type):
        arg_attrs = arg.__dict__.copy()
        for attr, val in arg.__dict__.items():
            if val in arg.__bases__:
                arg_attrs.pop(attr)

        for obj in arg_attrs.values():
            if isinstance(obj, types.FunctionType):
                obj.__no_type_check__ = True
            if isinstance(obj, type):
                no_type_check(obj)

    try:
        arg.__no_type_check__ = True
    except TypeError:
        pass

    return arg


def no_type_check_decorator(decorator):

    @functools.wraps(decorator)
    def wrapped_decorator(*args, **kwds):
        func = decorator(*args, **kwds)
        func = no_type_check(func)
        return func

    return wrapped_decorator


def _overload_dummy(*args, **kwds):
    raise NotImplementedError(b'You should not call an overloaded function. A series of @overload-decorated functions outside a stub module should always be followed by an implementation that is not @overload-ed.')


def overload(func):
    return _overload_dummy


class _ProtocolMeta(GenericMeta):

    def __instancecheck__(self, obj):
        if _Protocol not in self.__bases__:
            return super(_ProtocolMeta, self).__instancecheck__(obj)
        raise TypeError(b'Protocols cannot be used with isinstance().')

    def __subclasscheck__(self, cls):
        if not self._is_protocol:
            return NotImplemented
        if self is _Protocol:
            return True
        attrs = self._get_protocol_attrs()
        for attr in attrs:
            if not any(attr in d.__dict__ for d in cls.__mro__):
                return False

        return True

    def _get_protocol_attrs(self):
        protocol_bases = []
        for c in self.__mro__:
            if getattr(c, b'_is_protocol', False) and c.__name__ != b'_Protocol':
                protocol_bases.append(c)

        attrs = set()
        for base in protocol_bases:
            for attr in base.__dict__.keys():
                for c in self.__mro__:
                    if c is not base and attr in c.__dict__ and not getattr(c, b'_is_protocol', False):
                        break
                else:
                    if not attr.startswith(b'_abc_') and attr != b'__abstractmethods__' and attr != b'_is_protocol' and attr != b'__dict__' and attr != b'__args__' and attr != b'__slots__' and attr != b'_get_protocol_attrs' and attr != b'__next_in_mro__' and attr != b'__parameters__' and attr != b'__origin__' and attr != b'__orig_bases__' and attr != b'__extra__' and attr != b'__tree_hash__' and attr != b'__module__':
                        attrs.add(attr)

        return attrs


class _Protocol(object):
    __metaclass__ = _ProtocolMeta
    __slots__ = ()
    _is_protocol = True


Hashable = collections_abc.Hashable

class Iterable(Generic[T_co]):
    __slots__ = ()
    __extra__ = collections_abc.Iterable


class Iterator(Iterable[T_co]):
    __slots__ = ()
    __extra__ = collections_abc.Iterator


class SupportsInt(_Protocol):
    __slots__ = ()

    @abstractmethod
    def __int__(self):
        pass


class SupportsFloat(_Protocol):
    __slots__ = ()

    @abstractmethod
    def __float__(self):
        pass


class SupportsComplex(_Protocol):
    __slots__ = ()

    @abstractmethod
    def __complex__(self):
        pass


class SupportsAbs(_Protocol[T_co]):
    __slots__ = ()

    @abstractmethod
    def __abs__(self):
        pass


if hasattr(collections_abc, b'Reversible'):

    class Reversible(Iterable[T_co]):
        __slots__ = ()
        __extra__ = collections_abc.Reversible


else:

    class Reversible(_Protocol[T_co]):
        __slots__ = ()

        @abstractmethod
        def __reversed__(self):
            pass


Sized = collections_abc.Sized

class Container(Generic[T_co]):
    __slots__ = ()
    __extra__ = collections_abc.Container


class AbstractSet(Sized, Iterable[T_co], Container[T_co]):
    __slots__ = ()
    __extra__ = collections_abc.Set


class MutableSet(AbstractSet[T]):
    __slots__ = ()
    __extra__ = collections_abc.MutableSet


class Mapping(Sized, Iterable[KT], Container[KT], Generic[(KT, VT_co)]):
    __slots__ = ()
    __extra__ = collections_abc.Mapping


class MutableMapping(Mapping[(KT, VT)]):
    __slots__ = ()
    __extra__ = collections_abc.MutableMapping


if hasattr(collections_abc, b'Reversible'):

    class Sequence(Sized, Reversible[T_co], Container[T_co]):
        __slots__ = ()
        __extra__ = collections_abc.Sequence


else:

    class Sequence(Sized, Iterable[T_co], Container[T_co]):
        __slots__ = ()
        __extra__ = collections_abc.Sequence


class MutableSequence(Sequence[T]):
    __slots__ = ()
    __extra__ = collections_abc.MutableSequence


class ByteString(Sequence[int]):
    pass


ByteString.register(str)
ByteString.register(bytearray)

class List(list, MutableSequence[T]):
    __slots__ = ()
    __extra__ = list

    def __new__(cls, *args, **kwds):
        if _geqv(cls, List):
            raise TypeError(b'Type List cannot be instantiated; use list() instead')
        return _generic_new(list, cls, *args, **kwds)


class Deque(collections.deque, MutableSequence[T]):
    __slots__ = ()
    __extra__ = collections.deque

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Deque):
            return collections.deque(*args, **kwds)
        return _generic_new(collections.deque, cls, *args, **kwds)


class Set(set, MutableSet[T]):
    __slots__ = ()
    __extra__ = set

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Set):
            raise TypeError(b'Type Set cannot be instantiated; use set() instead')
        return _generic_new(set, cls, *args, **kwds)


class FrozenSet(frozenset, AbstractSet[T_co]):
    __slots__ = ()
    __extra__ = frozenset

    def __new__(cls, *args, **kwds):
        if _geqv(cls, FrozenSet):
            raise TypeError(b'Type FrozenSet cannot be instantiated; use frozenset() instead')
        return _generic_new(frozenset, cls, *args, **kwds)


class MappingView(Sized, Iterable[T_co]):
    __slots__ = ()
    __extra__ = collections_abc.MappingView


class KeysView(MappingView[KT], AbstractSet[KT]):
    __slots__ = ()
    __extra__ = collections_abc.KeysView


class ItemsView(MappingView[Tuple[(KT, VT_co)]], AbstractSet[Tuple[(KT, VT_co)]], Generic[(KT, VT_co)]):
    __slots__ = ()
    __extra__ = collections_abc.ItemsView


class ValuesView(MappingView[VT_co]):
    __slots__ = ()
    __extra__ = collections_abc.ValuesView


class ContextManager(Generic[T_co]):
    __slots__ = ()

    def __enter__(self):
        return self

    @abc.abstractmethod
    def __exit__(self, exc_type, exc_value, traceback):
        return

    @classmethod
    def __subclasshook__(cls, C):
        if cls is ContextManager and any(b'__enter__' in B.__dict__ for B in C.__mro__):
            if any(b'__exit__' in B.__dict__ for B in C.__mro__):
                return True
        return NotImplemented


class Dict(dict, MutableMapping[(KT, VT)]):
    __slots__ = ()
    __extra__ = dict

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Dict):
            raise TypeError(b'Type Dict cannot be instantiated; use dict() instead')
        return _generic_new(dict, cls, *args, **kwds)


class DefaultDict(collections.defaultdict, MutableMapping[(KT, VT)]):
    __slots__ = ()
    __extra__ = collections.defaultdict

    def __new__(cls, *args, **kwds):
        if _geqv(cls, DefaultDict):
            return collections.defaultdict(*args, **kwds)
        return _generic_new(collections.defaultdict, cls, *args, **kwds)


class Counter(collections.Counter, Dict[(T, int)]):
    __slots__ = ()
    __extra__ = collections.Counter

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Counter):
            return collections.Counter(*args, **kwds)
        return _generic_new(collections.Counter, cls, *args, **kwds)


if hasattr(collections_abc, b'Generator'):
    _G_base = collections_abc.Generator
else:
    _G_base = types.GeneratorType

class Generator(Iterator[T_co], Generic[(T_co, T_contra, V_co)]):
    __slots__ = ()
    __extra__ = _G_base

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Generator):
            raise TypeError(b'Type Generator cannot be instantiated; create a subclass instead')
        return _generic_new(_G_base, cls, *args, **kwds)


CT_co = TypeVar(b'CT_co', covariant=True, bound=type)

class Type(Generic[CT_co]):
    __slots__ = ()
    __extra__ = type


def NamedTuple(typename, fields):
    fields = [ (n, t) for n, t in fields ]
    cls = collections.namedtuple(typename, [ n for n, t in fields ])
    cls._field_types = dict(fields)
    try:
        cls.__module__ = sys._getframe(1).f_globals.get(b'__name__', b'__main__')
    except (AttributeError, ValueError):
        pass

    return cls


def NewType(name, tp):

    def new_type(x):
        return x

    new_type.__name__ = str(name)
    new_type.__supertype__ = tp
    return new_type


Text = unicode
TYPE_CHECKING = False

class IO(Generic[AnyStr]):
    __slots__ = ()

    @abstractproperty
    def mode(self):
        pass

    @abstractproperty
    def name(self):
        pass

    @abstractmethod
    def close(self):
        pass

    @abstractmethod
    def closed(self):
        pass

    @abstractmethod
    def fileno(self):
        pass

    @abstractmethod
    def flush(self):
        pass

    @abstractmethod
    def isatty(self):
        pass

    @abstractmethod
    def read(self, n=-1):
        pass

    @abstractmethod
    def readable(self):
        pass

    @abstractmethod
    def readline(self, limit=-1):
        pass

    @abstractmethod
    def readlines(self, hint=-1):
        pass

    @abstractmethod
    def seek(self, offset, whence=0):
        pass

    @abstractmethod
    def seekable(self):
        pass

    @abstractmethod
    def tell(self):
        pass

    @abstractmethod
    def truncate(self, size=None):
        pass

    @abstractmethod
    def writable(self):
        pass

    @abstractmethod
    def write(self, s):
        pass

    @abstractmethod
    def writelines(self, lines):
        pass

    @abstractmethod
    def __enter__(self):
        pass

    @abstractmethod
    def __exit__(self, type, value, traceback):
        pass


class BinaryIO(IO[bytes]):
    __slots__ = ()

    @abstractmethod
    def write(self, s):
        pass

    @abstractmethod
    def __enter__(self):
        pass


class TextIO(IO[unicode]):
    __slots__ = ()

    @abstractproperty
    def buffer(self):
        pass

    @abstractproperty
    def encoding(self):
        pass

    @abstractproperty
    def errors(self):
        pass

    @abstractproperty
    def line_buffering(self):
        pass

    @abstractproperty
    def newlines(self):
        pass

    @abstractmethod
    def __enter__(self):
        pass


class io(object):
    __all__ = [
     b'IO', b'TextIO', b'BinaryIO']
    IO = IO
    TextIO = TextIO
    BinaryIO = BinaryIO


io.__name__ = __name__ + b'.io'
sys.modules[io.__name__] = io
Pattern = _TypeAlias(b'Pattern', AnyStr, type(stdlib_re.compile(b'')), lambda p: p.pattern)
Match = _TypeAlias(b'Match', AnyStr, type(stdlib_re.match(b'', b'')), lambda m: m.re.pattern)

class re(object):
    __all__ = [
     b'Pattern', b'Match']
    Pattern = Pattern
    Match = Match


re.__name__ = __name__ + b'.re'
sys.modules[re.__name__] = re